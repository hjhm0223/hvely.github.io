{"componentChunkName":"component---src-templates-single-post-js","path":"/posts/di와-자동-di/","result":{"data":{"post":{"frontmatter":{"meta":{"title":"test meta title","description":"test meta description","noindex":null,"canonicalLink":null},"title":"DI와 자동 DI","template":"SinglePost","subtitle":null,"date":"April 7th, 2020","categories":[{"category":"Spring"}]},"html":"<h2>Spring은 객체 Container</h2>\n<ol>\n<li>Bean 객체</li>\n<li>Bean Factory에 저장되는 객체로 getBean() method를 통해 Bean 객체를 제공한다.</li>\n<li>getBean(\"Bean 이름\", Bean Type)</li>\n<li>Singleton 객체</li>\n<li>별도 설정을 하지 않을 경우 하나의 Bean 객체만을 생성한다.</li>\n</ol>\n<h2>자동 DI</h2>\n<ol>\n<li>\n<p><code>@Autowired</code></p>\n<ul>\n<li>스프링 '자동 의존 주입 기능'으로 Spring Bean에 의존하는 다른 Bean을 자동으로 주입하고 싶을 때 사용한다.</li>\n<li>'field'나 'setter method'에 사용하면 Type이 일치하는 Bean 객체를 찾아 자동 주입한다.</li>\n<li>일치하는 Bean이 없는 경우 - Error</li>\n<li>일치하는 Bean이 3개 이상인 경우 - Error (@Qualifier를 이용하여 의존 객체 선택할 수 있다.)</li>\n<li>반드시 setter method를 통해 의존 객체를 주입할 필요는 없다.</li>\n<li>자동 주입할 대상이 필수가 아닌 경우: @Autowired(required=false)로 지정</li>\n<li>Optional을 사용</li>\n<li>@Nullable 사용</li>\n</ul>\n</li>\n<li>\n<p><code>@Import</code></p>\n<ul>\n<li>함께 사용할 설정 Class를 지정한다.</li>\n</ul>\n</li>\n<li><code>@Qualifier</code></li>\n</ol>\n<h3>@ComponentScan</h3>\n<ul>\n<li>\n<p>@Component와 @Service, @Repository, @Controller, @Configuration이 붙은 클래스 Bean들을 찾아서 Context에 bean등록을 해주는 Annotation</p>\n<p>ApplicationContext.xml에 <bean id=\"jeongpro\" class=\"jeongpro\" /> 이런식으로 xml에 bean을 직접등록하는 방법도 있고 위와 같이 애노테이션을 붙여서 하는 방법도 있음</p>\n<p>base-package를 넣으면 해당 패키지 아래에 있는 컴포넌트들을 찾고 그 과정을 spring-context-버전(4.3.11.RELEASE).jar에서 처리한다.</p>\n<p>@Component로 다 쓰지 왜 굳이 @Repository, @Service, @Controller등을 사용하냐면 예를들어 @Repository는 DAO의 메소드에서 발생할 수 있는 unchecked exception들을 스프링의 DataAccessException으로 처리할 수 있기 때문이다. 또한 가독성에서도 해당 애노테이션을 갖는 클래스가 무엇을 하는지 단 번에 알 수 있다.</p>\n<p>그리고 그렇게 작성하면 자동으로 등록되는 빈의 이름은 클래스의 첫문자가 소문자로 바뀐 이름이 자동적용된다.</p>\n<p>(HomeController -> homeController)</p>\n</li>\n</ul>\n<h3>@EnableAutoConfiguration</h3>\n<ul>\n<li>\n<p>스프링 애플리케이션 컨텍스트를 만들 때 자동으로 설정하는 기능을 켠다.</p>\n<p>classpath의 내용에 기반해서 자동 생성해준다. 만약 tomcat-embed-core.jar가 존재하면 톰캣 서버가 setting된다.</p>\n</li>\n</ul>\n<h3>@Configuration</h3>\n<ul>\n<li>Configuration을 클래스에 적용하고 @Bean을 해당 클래스의 메소드에 적용하면 @Autowired로 빈을 부를 수 있다.</li>\n</ul>\n<h3>@Required</h3>\n<ul>\n<li>setter 메서드에 적용해주면 빈 생성시 필수 프로퍼티 임을 알린다.</li>\n</ul>\n<h3>@Qualifier(\"id123\")</h3>\n<ul>\n<li>\n<p>@Autowired와 같이 쓰이며, 같은 타입의 빈 객체가 있을 때 해당 아이디를 적어 원하는 빈이 주입될 수 있도록 하는 애노테이션</p>\n<p>(같은 타입이 존재하는 경우 ex) 동물, 원숭이, 닭, 개, 돼지)</p>\n</li>\n</ul>\n<h3>@Resource</h3>\n<ul>\n<li>@Autowired와 마찬가지로 빈 객체를 주입해주는데 차이점은 Autowired는 타입으로, Resource는 이름으로 연결해준다.</li>\n</ul>\n<h3>@PostConstruct, @PreConstruct</h3>\n<ul>\n<li>의존하는 객체를 생성한 이후 초기화 작업을 위해 객체 생성 전/후에(pre/post) 실행해야 할 메소드 앞에 붙인다.</li>\n</ul>\n<h3>@PreDestroy</h3>\n<ul>\n<li>객체를 제거하기 전(pre)에 해야할 작업을 수행하기 위해 사용한다.</li>\n</ul>\n<h3>@PropertySource</h3>\n<ul>\n<li>\n<p>해당 프로퍼티 파일을 Environment로 로딩하게 해준다.</p>\n<p>클래스에 @PropertySource(\"classpath:/settings.properties\")라고 적고 클래스 내부에 @Resource를 Environment타입의 멤버변수앞에 적으면 매핑된다.</p>\n</li>\n</ul>\n<h3>@ConfigurationProperties</h3>\n<ul>\n<li>\n<p>yaml파일 읽는다. default로 classpath:application.properties 파일이 조회된다.</p>\n<p>속성 클래스를 따로 만들어두고 그 위에 (prefix=\"mail\")을 써서 프로퍼티의 접두사를 사용할 수 있음</p>\n<p>mail.host = mailserver@mail.com</p>\n<p>mail.port = 9000</p>\n<p>mail.defaultRecipients[0] = admin@mail.com</p>\n<p>mail.defaultRecipients[1] = customer@mail.com</p>\n</li>\n</ul>\n<h3>@Lazy</h3>\n<ul>\n<li>\n<p>지연로딩을 지원한다.</p>\n<p>@Component나 @Bean 애노티에션과 같이 쓰는데 클래스가 로드될 때 스프링에서 바로 bean등록을 마치는 것이 아니라 실제로 사용될 때 로딩이 이뤄지게 하는 방법이다.</p>\n</li>\n</ul>\n<h3>@Value</h3>\n<ul>\n<li>properties에서 값을 가져와 적용할 때 사용한다.</li>\n</ul>\n<h3>@Value(\"${value.from.file}\")</h3>\n<p>private String valueFromFile; 이라고 구성되어 있으면 value.from.file의 값을 가져와서 해당 변수에 주입해준다.</p>\n<p>spEL을 이용해서 조금 더 고급스럽게 쓸 수 있다.</p>\n<h3>@Value(#{systemProperties['priority'] ?: 'some default'})</h3>\n<h3>@SpringBootApplication</h3>\n<ul>\n<li>@Configuration, @EnableAutoConfiguration, @ComponentScan 3가지를 하나의 애노테이션으로 합친 것이다.</li>\n</ul>\n<h3>@RequestMapping</h3>\n<ul>\n<li>\n<p>요청 URL을 어떤 메서드가 처리할지 mapping해주는 애노테이션이다.</p>\n<p>컨트롤러나 컨트롤러의 메서드에 적용한다.</p>\n<p>@RequestMapping(\"/list\"), @RequestMapping(\"/home, /about\");</p>\n<p>@RequestMapping(\"/admin\", method=RequestMethod.GET)</p>\n</li>\n</ul>\n<h3>@CookieValue</h3>\n<ul>\n<li>\n<p>쿠기 값을 파라미터로 전달 받을 수 있는 방법</p>\n<p>해당 쿠기가 존재하지 않으면 500 에러를 발생시킨다.</p>\n<p>속성으로 required가 있는데 default는 true다. false를 적용하면 해당 쿠키 값이 없을 때 null로 받고 에러를 발생시키지 않는다.</p>\n<p>public String view(@CookieValue(value=\"auth\")String auth){...}; // 쿠키의 key가 auth에 해당하는 값을 가져옴</p>\n</li>\n</ul>\n<h3>@CrossOrigin</h3>\n<ul>\n<li>\n<p>CORS 보안상의 문제로 브라우저에서 리소스를 현재 origin에서 다른 곳으로의 AJAX요청을 방지하는 것이다.</p>\n<p>@RequestMapping이 있는 곳에 사용하면 해당 요청은 타 도메인에서 온 ajax요청을 처리해준다.</p>\n<p>@CrossOrigin(origins = \"<a href=\"http://jeong-pro.tistory.com%22\">http://jeong-pro.tistory.com\"</a>, maxAge = 3600)</p>\n<p>-> 기본 도메인이 <a href=\"http://jeong-pro.tistory.com\">http://jeong-pro.tistory.com</a> 인 곳에서 온 ajax요청만 받아주겠다.</p>\n</li>\n</ul>\n<h3>@ModelAttribute</h3>\n<ul>\n<li>\n<p>view에서 전달해주는 파라미터를 클래스(VO/DTO)의 멤버 변수로 binding 해주는 애노테이션</p>\n<p>바인딩 기준은 <code>&#x3C;input name=\"id\" /></code>처럼 어떤 태그의 name값이 해당 클래스의 멤버 변수명과 일치해야하고 set메서드명도 일치해야한다.</p>\n<pre><code>class Person{\nString id;\npublic void setId(String id){ this.id = id;}\n}\n</code></pre>\n</li>\n</ul>\n<h3>@GetMapping</h3>\n<ul>\n<li>\n<p>@RequestMapping(Method=RequestMethod.GET)과 같음</p>\n<p>@PostMapping, @PutMapping, @PatchMapping, @DeleteMapping은 유추 가능함.</p>\n</li>\n</ul>\n<h3>@SessionAttributes</h3>\n<ul>\n<li>\n<p>세션에 데이터를 넣을 때 쓰는 애노테이션</p>\n<p>@SessionAttributes(\"name\")이라고 하면 Model에 key값이 \"name\"으로 있는 값은 자동으로 세션에도 저장되게 한다.</p>\n</li>\n</ul>\n<h3>@Valid</h3>\n<ul>\n<li>유효성 검증이 필요한 객체임을 지정한다.</li>\n</ul>\n<h3>@InitBinder</h3>\n<ul>\n<li>@Valid 애노테이션으로 유효성 검증이 필요하다고 한 객체를 가져오기전에 수행해야할 메서드를 지정한다.</li>\n</ul>\n<h3>@RequestAttribute</h3>\n<ul>\n<li>Request에 설정되어 있는 속성 값을 가져올 수 있다.</li>\n</ul>\n<h3>@RequestBody</h3>\n<ul>\n<li>요청이 온 데이터(JSON이나 XML형식)를 바로 클래스나 model로 매핑하기 위한 애노테이션</li>\n</ul>\n<h3>@RequestHeader</h3>\n<ul>\n<li>\n<p>Request의 header값을 가져올 수 있다. 메소드의 파라미터에 사용</p>\n<p>@RequestHeader(value=\"Accept-Language\")String acceptLanguage 로 사용 //ko-KR,ko;q=0.8,en-US;q=0.6</p>\n</li>\n</ul>\n<h3>@RequestParam</h3>\n<ul>\n<li>@PathVariable과 비슷하다. request의 parameter에서 가져오는 것이다. 메소드의 파라미터에 사용됨</li>\n</ul>\n<h3>@RequestPart</h3>\n<ul>\n<li>\n<p>Request로 온 MultipartFile을 바인딩해준다.</p>\n<p>@RequestPart(\"file\")MultipartFile file로 받아올 수 있음.</p>\n</li>\n</ul>\n<h3>@ResponseBody</h3>\n<ul>\n<li>\n<p>view가 아닌 JSON 형식의 값을 응답할 때 사용하는 애노테이션으로 문자열을 리턴하면 그 값을 http response header가 아닌 response body에 들어간다.</p>\n<p>만약 객체를 return하는 경우 JACKSON 라이브러리에 의해 문자열로 변환되어 전송된다.</p>\n<p>context에 설정된 resolver를 무시한다고 보면된다. (viewResolver)</p>\n</li>\n</ul>\n<h3>@PathVariable</h3>\n<ul>\n<li>메서드 파라미터 앞에 사용하면서 해당 URL에서 {특정값}을 변수로 받아 올 수 있다.</li>\n</ul>\n<h3>@ExceptionHandler(ExceptionClassName.class)</h3>\n<ul>\n<li>해당 클래스의 예외를 캐치하여 처리한다.</li>\n</ul>\n<h3>@ControllerAdvice</h3>\n<ul>\n<li>클래스 위에 ControllerAdvice를 붙이고 어떤 예외를 잡아낼 것인지는 각 메소드 상단에 @ExceptionHandler(에외클래스명.class)를 붙여서 기술한다.</li>\n</ul>\n<h3>@RestControllerAdvice</h3>\n<ul>\n<li>문법적 설탕으로 @ControllerAdvice + @ResponseBody다.</li>\n</ul>\n<h3>@ResponseStatus</h3>\n<ul>\n<li>\n<p>사용자에게 원하는 response code와 reason을 리턴해주는 애노테이션</p>\n<p>@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = \"my page URL changed..\") => 예외처리 함수 앞에 사용한다.</p>\n</li>\n</ul>\n<h3>@EnableEurekaServer</h3>\n<ul>\n<li>Eureka 서버로 만들어준다.</li>\n</ul>\n<h3>@EnableDiscoveryClient</h3>\n<ul>\n<li>Eureka 서버에서 관리될 수 있는 클라이언트 임을 알려주기위한 애노테이션</li>\n</ul>\n<h3>@Transactional</h3>\n<ul>\n<li>\n<p>데이터베이스 트랜잭션을 설정하고 싶은 메서드에 애노테이션을 적용하면 메서드 내부에서 일어나는 데이터베이스 로직이 전부 성공하게되거나 데이터베이스 접근중 하나라도 실패하면 다시 롤백할 수 있게 해주는 애노테이션</p>\n<p>@Transaction(readOnly=true, rollbackFor=Exception.class) : readOnly는 읽기전용임을 알리고 rollbackFor는 해당 Exception이 생기면 롤백하라는 뜻</p>\n<p>@Transaction(noRollbackFor=Exception.class)는 해당 Exception이 나타나도 롤백하지 말라는 뜻</p>\n<p>@Transaction(timeout = 10)은 10초안에 해당 로직을 수행하지 못하면 롤백하라는 뜻.</p>\n</li>\n</ul>\n<h3>@Cacheable</h3>\n<ul>\n<li>\n<p>메서드 앞에 지정하면 해당 메서드를 최초에 호출하면 캐시에 적재하고 다음부터는 동일한 메서드 호출이 있을 때 캐시에서 결과를 가져와서 리턴하므로 메서드호출 횟수를 줄여주는 애노테이션</p>\n<p>주의할 점은 입력이 같으면 항상 출력이 같은 메서드(=순수 함수)에 적용해야한다.</p>\n<p>그런데 또 항상 같은 값만 뱉어주는 메서드에 적용하려면 조금 아쉬울 수 있다. 따라서 메서드 호출에 사용되는 자원이 많고 자주 변경되지 않을 때 사용하고 나중에 수정되면 캐시를 없애는 방법을 선택할 수 있다.</p>\n<p>@Cacheable(value=\"cacheKey\"), @Cacheable(key=\"cacheKey\")</p>\n</li>\n</ul>\n<h3>@CachePut</h3>\n<ul>\n<li>\n<p>캐시를 업데이트하기 위해서 메서드를 항상 실행하게 강제하는 애노테이션</p>\n<p>해당 애노테이션이 있으면 메서드호출을 항상한다. 그러므로 @Cacheable과 상충되어 같이 사용하면 안된다.</p>\n</li>\n</ul>\n<h3>@CacheEvict</h3>\n<ul>\n<li>\n<p>캐시에서 데이터를 제거하는 트리거로 동작하는 메소드</p>\n<p>캐시된 데이터는 언제가는 지워져야한다. 그러지 않으면 결과값이 변경이 일어났는데도 기존의 데이터(캐시된 데이터)를 불러와서 오류가 발생할 수 있다.</p>\n<p>물론 캐시 설정에서 캐시 만료시간을 줄 수도 있다.</p>\n<p>@CacheEvict(value=\"cacheKey\"), @CacheEvict(value=\"cacheKey\", allEntries=true)</p>\n<p>allEntries는 전체 캐시를 지울지 여부를 선택하는 것이다.</p>\n</li>\n</ul>\n<h3>@CacheConfig</h3>\n<ul>\n<li>클래스 레벨에서 공통의 캐시설정을 공유하는 기능이다.</li>\n</ul>\n<h3>@Scheduled</h3>\n<ul>\n<li>\n<p>Linux의 crontab처럼 뭔가 정해진 시간에 실행해야하는 경우에 사용한다.</p>\n<p>@Scheduled(cron = \"0 0 07 * * ?\") \"초 분 시 일 월 요일 년(선택)에 해당 메서드 호출</p>\n</li>\n</ul>","id":"443ae298-350d-531c-a42c-34e0acb0cdd8"},"allPosts":{"edges":[{"node":{"id":"f5d1f1a7-7c2c-5f6a-9046-a6fe333a0e41"},"next":{"fields":{"slug":"/posts/kafka/"},"frontmatter":{"title":"Kafka"}},"previous":null},{"node":{"id":"827bacda-b789-58c1-b114-dd1a84d2cf0b"},"next":{"fields":{"slug":"/posts/tdd-sample-project/"},"frontmatter":{"title":"TDD SAMPLE PROJECT"}},"previous":{"fields":{"slug":"/posts/spring-integration-구조/"},"frontmatter":{"title":"Spring Integration 구조"}}},{"node":{"id":"fe264f59-bd9f-53c6-97e3-5d09ab013a63"},"next":{"fields":{"slug":"/posts/e-tas-server-to-server-연동-batch/"},"frontmatter":{"title":"eTAS Server to Server 연동 Batch"}},"previous":{"fields":{"slug":"/posts/kafka/"},"frontmatter":{"title":"Kafka"}}},{"node":{"id":"24b2dd59-8191-53ef-a9a4-d121eb896a0e"},"next":{"fields":{"slug":"/posts/spring-batch/"},"frontmatter":{"title":"Spring Batch"}},"previous":{"fields":{"slug":"/posts/tdd-sample-project/"},"frontmatter":{"title":"TDD SAMPLE PROJECT"}}},{"node":{"id":"7b317632-317d-580c-bfa6-c53f96edeb52"},"next":{"fields":{"slug":"/posts/react-project-개발기/"},"frontmatter":{"title":"React Project 개발기"}},"previous":{"fields":{"slug":"/posts/e-tas-server-to-server-연동-batch/"},"frontmatter":{"title":"eTAS Server to Server 연동 Batch"}}},{"node":{"id":"e29c2d7f-1fd2-5913-a904-11996c231f54"},"next":{"fields":{"slug":"/posts/hadoop/"},"frontmatter":{"title":"Hadoop"}},"previous":{"fields":{"slug":"/posts/spring-batch/"},"frontmatter":{"title":"Spring Batch"}}},{"node":{"id":"7f695fca-e5ce-5c55-970b-e8855f99b61a"},"next":{"fields":{"slug":"/posts/java-script-1-개요/"},"frontmatter":{"title":"JavaScript (1) - 개요"}},"previous":{"fields":{"slug":"/posts/react-project-개발기/"},"frontmatter":{"title":"React Project 개발기"}}},{"node":{"id":"9f46ad6e-455d-53e9-8d4c-4794e5af39dd"},"next":{"fields":{"slug":"/posts/java-script-3-제어흐름과-에러처리-loop-함수-표현식과-연산자-숫자와-날짜-텍스트-서식-정규-표현식/"},"frontmatter":{"title":"JavaScript (3) - 제어흐름과 에러처리, Loop, 함수, 표현식과 연산자, 숫자와 날짜, 텍스트 서식, 정규 표현식"}},"previous":{"fields":{"slug":"/posts/hadoop/"},"frontmatter":{"title":"Hadoop"}}},{"node":{"id":"7470f1ce-f71d-5772-a8be-806ed3f7cc66"},"next":{"fields":{"slug":"/posts/java-script-2-문법과-자료형/"},"frontmatter":{"title":"JavaScript (2) - 문법과 자료형"}},"previous":{"fields":{"slug":"/posts/java-script-1-개요/"},"frontmatter":{"title":"JavaScript (1) - 개요"}}},{"node":{"id":"27ea8f29-94a3-5302-a637-efd0af842208"},"next":{"fields":{"slug":"/posts/java-script-4-loop와-반복-함수-표현식과-연산자-숫자와-날자-텍스트-서식-정규표현식/"},"frontmatter":{"title":"JavaScript (4) - Loop와 반복, 함수, 표현식과 연산자, 숫자와 날자, 텍스트 서식, 정규표현식"}},"previous":{"fields":{"slug":"/posts/java-script-3-제어흐름과-에러처리-loop-함수-표현식과-연산자-숫자와-날짜-텍스트-서식-정규-표현식/"},"frontmatter":{"title":"JavaScript (3) - 제어흐름과 에러처리, Loop, 함수, 표현식과 연산자, 숫자와 날짜, 텍스트 서식, 정규 표현식"}}},{"node":{"id":"c54308e0-d7a2-5d1c-b8ae-ecbfd04ed1ac"},"next":{"fields":{"slug":"/posts/java-script-5-collections/"},"frontmatter":{"title":"JavaScript (5) - Collections"}},"previous":{"fields":{"slug":"/posts/java-script-2-문법과-자료형/"},"frontmatter":{"title":"JavaScript (2) - 문법과 자료형"}}},{"node":{"id":"c8b65dec-7fef-5ef0-a515-27ae182dff3e"},"next":{"fields":{"slug":"/posts/java-script-6-objects/"},"frontmatter":{"title":"JavaScript (6) - Objects"}},"previous":{"fields":{"slug":"/posts/java-script-4-loop와-반복-함수-표현식과-연산자-숫자와-날자-텍스트-서식-정규표현식/"},"frontmatter":{"title":"JavaScript (4) - Loop와 반복, 함수, 표현식과 연산자, 숫자와 날자, 텍스트 서식, 정규표현식"}}},{"node":{"id":"6814abc2-41a1-520c-bd24-a8d2d02424fb"},"next":{"fields":{"slug":"/posts/java-script-7-반복기-및-생성기-메타-프로그래밍/"},"frontmatter":{"title":"JavaScript (7) - 반복기 및 생성기, 메타 프로그래밍"}},"previous":{"fields":{"slug":"/posts/java-script-5-collections/"},"frontmatter":{"title":"JavaScript (5) - Collections"}}},{"node":{"id":"2fa87adf-6f94-54db-a8e4-7ab4990ba5e6"},"next":{"fields":{"slug":"/posts/ci-cd/"},"frontmatter":{"title":"CI/CD"}},"previous":{"fields":{"slug":"/posts/java-script-6-objects/"},"frontmatter":{"title":"JavaScript (6) - Objects"}}},{"node":{"id":"2311c1d2-b785-582e-a9a9-d80750b5d505"},"next":{"fields":{"slug":"/posts/restful-api/"},"frontmatter":{"title":"Restful API"}},"previous":{"fields":{"slug":"/posts/java-script-7-반복기-및-생성기-메타-프로그래밍/"},"frontmatter":{"title":"JavaScript (7) - 반복기 및 생성기, 메타 프로그래밍"}}},{"node":{"id":"54319bda-39af-5fa4-9eee-7f84ee580c1a"},"next":{"fields":{"slug":"/posts/di와-자동-di/"},"frontmatter":{"title":"DI와 자동 DI"}},"previous":{"fields":{"slug":"/posts/ci-cd/"},"frontmatter":{"title":"CI/CD"}}},{"node":{"id":"443ae298-350d-531c-a42c-34e0acb0cdd8"},"next":{"fields":{"slug":"/posts/annotation/"},"frontmatter":{"title":"Annotation"}},"previous":{"fields":{"slug":"/posts/restful-api/"},"frontmatter":{"title":"Restful API"}}},{"node":{"id":"2e8c37a8-a44a-5356-b617-dc7b22034c2a"},"next":{"fields":{"slug":"/posts/spring-mvc-pattern/"},"frontmatter":{"title":"Spring MVC Pattern"}},"previous":{"fields":{"slug":"/posts/di와-자동-di/"},"frontmatter":{"title":"DI와 자동 DI"}}},{"node":{"id":"64980158-2ad8-5c44-91a8-a0185a6d4f6b"},"next":{"fields":{"slug":"/posts/orm과-jpa-2/"},"frontmatter":{"title":"ORM과 JPA (2)"}},"previous":{"fields":{"slug":"/posts/annotation/"},"frontmatter":{"title":"Annotation"}}},{"node":{"id":"5128821c-b701-5848-9979-bb91ec9c5836"},"next":{"fields":{"slug":"/posts/orm과-jpa-1/"},"frontmatter":{"title":"ORM과 JPA (1)"}},"previous":{"fields":{"slug":"/posts/spring-mvc-pattern/"},"frontmatter":{"title":"Spring MVC Pattern"}}},{"node":{"id":"d4549afd-0095-5810-b492-b843ca6e2f88"},"next":{"fields":{"slug":"/posts/apache-spark-2-rdd/"},"frontmatter":{"title":"Apache Spark (2) - RDD"}},"previous":{"fields":{"slug":"/posts/orm과-jpa-2/"},"frontmatter":{"title":"ORM과 JPA (2)"}}},{"node":{"id":"e46642ac-6d65-51b8-a535-21a9e3eabb56"},"next":{"fields":{"slug":"/posts/apache-spark-1-개요/"},"frontmatter":{"title":"Apache Spark (1) - 개요"}},"previous":{"fields":{"slug":"/posts/orm과-jpa-1/"},"frontmatter":{"title":"ORM과 JPA (1)"}}},{"node":{"id":"46426481-29ee-5d00-aa6c-cf05d52490f6"},"next":{"fields":{"slug":"/posts/동시성-처리/"},"frontmatter":{"title":"동시성 처리"}},"previous":{"fields":{"slug":"/posts/apache-spark-2-rdd/"},"frontmatter":{"title":"Apache Spark (2) - RDD"}}},{"node":{"id":"6eed9dfa-e294-5b19-a225-cd43d6cb982a"},"next":{"fields":{"slug":"/posts/database/"},"frontmatter":{"title":"DATABASE"}},"previous":{"fields":{"slug":"/posts/apache-spark-1-개요/"},"frontmatter":{"title":"Apache Spark (1) - 개요"}}},{"node":{"id":"f77c8cbf-3a58-53fc-bd32-592702676a11"},"next":{"fields":{"slug":"/posts/erd/"},"frontmatter":{"title":"ERD"}},"previous":{"fields":{"slug":"/posts/동시성-처리/"},"frontmatter":{"title":"동시성 처리"}}},{"node":{"id":"f016fc75-8476-5493-8ac1-e2862773f3e7"},"next":{"fields":{"slug":"/posts/git-사용법/"},"frontmatter":{"title":"Git 사용법"}},"previous":{"fields":{"slug":"/posts/database/"},"frontmatter":{"title":"DATABASE"}}},{"node":{"id":"9f5a9a91-7af6-5ca3-b20f-d6e177e46c68"},"next":{"fields":{"slug":"/posts/jpa-1-query/"},"frontmatter":{"title":"JPA (1) - Query"}},"previous":{"fields":{"slug":"/posts/erd/"},"frontmatter":{"title":"ERD"}}},{"node":{"id":"b4e07799-70a4-523d-90ec-741e18230194"},"next":{"fields":{"slug":"/posts/jpa-2-specification/"},"frontmatter":{"title":"JPA (2) - Specification"}},"previous":{"fields":{"slug":"/posts/git-사용법/"},"frontmatter":{"title":"Git 사용법"}}},{"node":{"id":"571df319-d1dd-59b6-a588-7a5db12c6b3d"},"next":{"fields":{"slug":"/posts/j-query/"},"frontmatter":{"title":"jQuery"}},"previous":{"fields":{"slug":"/posts/jpa-1-query/"},"frontmatter":{"title":"JPA (1) - Query"}}},{"node":{"id":"ef05bf06-2d53-5323-820b-98f46a906289"},"next":{"fields":{"slug":"/posts/kubernetes/"},"frontmatter":{"title":"Kubernetes"}},"previous":{"fields":{"slug":"/posts/jpa-2-specification/"},"frontmatter":{"title":"JPA (2) - Specification"}}},{"node":{"id":"a78eb59a-78b3-5c86-bcc2-f09ea58fab23"},"next":{"fields":{"slug":"/posts/node-js/"},"frontmatter":{"title":"NodeJS"}},"previous":{"fields":{"slug":"/posts/j-query/"},"frontmatter":{"title":"jQuery"}}},{"node":{"id":"3c37f3d1-7097-5528-a31b-12bcdcd937ab"},"next":{"fields":{"slug":"/posts/oop/"},"frontmatter":{"title":"OOP"}},"previous":{"fields":{"slug":"/posts/kubernetes/"},"frontmatter":{"title":"Kubernetes"}}},{"node":{"id":"fe690dd1-ec0c-544b-a44f-131d80987565"},"next":{"fields":{"slug":"/posts/postgre-sql-2-psql/"},"frontmatter":{"title":"PostgreSQL (2) - PSQL"}},"previous":{"fields":{"slug":"/posts/node-js/"},"frontmatter":{"title":"NodeJS"}}},{"node":{"id":"b8c8c26f-09bc-5759-8a7e-c81ffbc8f2c0"},"next":{"fields":{"slug":"/posts/postgre-sql-1-개요/"},"frontmatter":{"title":"PostgreSQL (1) - 개요"}},"previous":{"fields":{"slug":"/posts/oop/"},"frontmatter":{"title":"OOP"}}},{"node":{"id":"6268f141-e6af-5f89-a55b-2174ef57651f"},"next":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}},"previous":{"fields":{"slug":"/posts/postgre-sql-2-psql/"},"frontmatter":{"title":"PostgreSQL (2) - PSQL"}}},{"node":{"id":"1a663d51-139e-500f-a209-04faaebd2e85"},"next":{"fields":{"slug":"/posts/react-hook/"},"frontmatter":{"title":"React Hook"}},"previous":{"fields":{"slug":"/posts/postgre-sql-1-개요/"},"frontmatter":{"title":"PostgreSQL (1) - 개요"}}},{"node":{"id":"b227a2c1-7853-5450-a1be-f3e1c83307b4"},"next":{"fields":{"slug":"/posts/redux-react-redux/"},"frontmatter":{"title":"Redux & React-Redux"}},"previous":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}}},{"node":{"id":"80979747-a7b7-5e5d-81bb-30729e2e16bd"},"next":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}},"previous":{"fields":{"slug":"/posts/react-hook/"},"frontmatter":{"title":"React Hook"}}},{"node":{"id":"a82c048c-1eea-54e3-912d-ae875640e04e"},"next":{"fields":{"slug":"/posts/swagger/"},"frontmatter":{"title":"Swagger"}},"previous":{"fields":{"slug":"/posts/redux-react-redux/"},"frontmatter":{"title":"Redux & React-Redux"}}},{"node":{"id":"18c2a54b-1a71-511c-824c-f437be00f3ef"},"next":{"fields":{"slug":"/posts/tomcat-사용법/"},"frontmatter":{"title":"Tomcat 사용법"}},"previous":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}}},{"node":{"id":"d2056881-058f-5f23-88ec-cf613dff77f0"},"next":{"fields":{"slug":"/posts/web-rtc/"},"frontmatter":{"title":"WebRTC"}},"previous":{"fields":{"slug":"/posts/swagger/"},"frontmatter":{"title":"Swagger"}}},{"node":{"id":"d54a4c19-013d-538a-893d-ff8f62d34d7a"},"next":null,"previous":{"fields":{"slug":"/posts/tomcat-사용법/"},"frontmatter":{"title":"Tomcat 사용법"}}}]}},"pageContext":{"id":"443ae298-350d-531c-a42c-34e0acb0cdd8"}},"staticQueryHashes":["2001315320"]}