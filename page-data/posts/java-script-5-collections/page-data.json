{"componentChunkName":"component---src-templates-single-post-js","path":"/posts/java-script-5-collections/","result":{"data":{"post":{"frontmatter":{"meta":{"title":"test meta title","description":"test meta description","noindex":null,"canonicalLink":null},"title":"JavaScript (5) - Collections","template":"SinglePost","subtitle":null,"date":"July 29th, 2021","categories":[{"category":"JavaScript"}]},"html":"<p><img src=\"https://gawoori.net/wp-content/uploads/2018/04/javascript-frameworks.jpg\" alt=\"javascript\"></p>\n<h1>JavaScript (5) - Collections</h1>\n<h2>Indexed Collections</h2>\n<h3>배열 객체</h3>\n<ul>\n<li>배열은 이름과 인덱스로 참조되는 정렬된 값들의 집합이다. 예를 들면, 숫자로 된 사원번호를 index로하여 사원명을 가지고 있는 emp라는 배열을 가질 수 있다.</li>\n<li>자바스크립트는 명시적인 배열 데이터 형식을 가지고 있지 않지만 미리 정의된 배열 객체를 사용할 수 있고 배열 객체의 메서드를 개발하는 어플리케이션에서 사용되는 배열에 사용할 수 있다. </li>\n<li>배열 객체는 합치기(joining), 순서 뒤집기(reversing) 그리고 정렬(sorting)과 같은 다양한 방법으로 배열을 조작하는 메서드들을 제공한다. 정규 표현식과 함께 사용할 배열 길이와 기타 속성을 결정하는 속성이 있다.</li>\n<li>\n<p>배열 생성하는 방법</p>\n<pre><code class=\"language-javascript\">var arr = new Array(element0, element1, ..., elementN);\nvar arr = Array(element0, element1, ..., elementN);\nvar arr = [element0, element1, ..., elementN];\n\n// 길이가 0보다 크지만 아무런 요소를 가지고 있지 않은 배열\nnew Array(상수);\n\n// 배열 활용\nvar colors = ['red', 'green', 'blue'];\nfor (var i = 0; i &#x3C; colors.length; i++) {\nconsole.log(colors[i]);\n}\n</code></pre>\n</li>\n</ul>\n<h3>배열 객체의 메서드</h3>\n<ol>\n<li><code>concat()</code> 메서드 두개의 배열을 합쳐 새로운 배열을 반환한다.</li>\n<li>\n<p><code>join(delimiter = ',')</code> 메서드는 배열의 모든 요소를 주어진 구분자로 연결된 하나의 문자열을 반환한다.</p>\n<pre><code class=\"language-javascript\">var myArray = new Array('Wind', 'Rain', 'Fire');\nvar list = myArray.join(' - '); // list is \"Wind - Rain - Fire\"\n</code></pre>\n</li>\n<li><code>push()</code> 메서드는 하나 혹은 그 이상의 요소를 배열의 마지막에 추가하고 추가된 요소를 포함한 길이를 반환한다.</li>\n<li>\n<p><code>pop()</code> 메서드는 배열의 마지막 요소를 제거 하고 그 제거된 요소를 반환한다.</p>\n<pre><code class=\"language-javascript\">var myArray = new Array('1', '2', '3');\nvar last = myArray.pop();\n// myArray is now [\"1\", \"2\"], last = \"3\"\n</code></pre>\n</li>\n<li><code>shift()</code> 메서드는 배열의 첫번째 요소를 제거하고 그 제거된 요소를 반환한다.</li>\n<li>\n<p><code>unshift()</code> 메서드는 하나 혹은 그 이상의 요소를 배열의 앞쪽에 추가하고 추가한 요소를 포함한 길이를 반환한다.</p>\n<pre><code class=\"language-javascript\">var myArray = new Array('1', '2', '3');\nmyArray.unshift('4', '5');\n// myArray becomes [\"4\", \"5\", \"1\", \"2\", \"3\"]\n</code></pre>\n</li>\n<li>\n<p><code>slice(start_index, upto_index)</code> 메서드는 배열의 특정 부분을 추출하여 그 추출된 부분을 포함하는 새로운 배열을 반환한다. upto_index에 해당하는 요소는 포함되지 않는다.   </p>\n<p><code>splice(index, count_to_remove, addElement1, addElement2, ...)</code> 메서드는 주어진 인덱스 요소를 포함하여 count<em>to</em>remove 개수만큼 삭제하고 주어진 요소로. 바꿔준다. </p>\n</li>\n<li><code>reverse ()</code> 메서드는 배열의 요소를 반대자리에 배치한다.</li>\n<li>\n<p><code>sort ()</code> 배열의 요소를 제자리에 정렬하고 배열에 대한 참조를 반환한다.  </p>\n<pre><code class=\"language-javascript\">var myArray = new Array('Wind', 'Rain', 'Fire');\nmyArray.sort();\n\n// 어떻게 해당 배열의 요소를 정렬할 지 결정하는 콜백 함수를 인자로 줄 수 있다.\nvar sortFn = function(a, b){\n if (a[a.length - 1] &#x3C; b[b.length - 1]) return -1;\n if (a[a.length - 1] > b[b.length - 1]) return 1;\n if (a[a.length - 1] == b[b.length - 1]) return 0;\n}\n\nmyArray.sort(sortFn);\n// sorts the array so that myArray = [\"Wind\",\"Fire\",\"Rain\"]\n</code></pre>\n</li>\n<li>\n<p><code>indexOf (searchElement [, fromIndex\\])</code> 는 배열에서 <code>searchElement</code>를 검색하고 첫 번째 일치 항목의 인덱스를 반환한다. </p>\n<p> <code>lastIndexOf(searchElement[, fromIndex\\])</code> 메서드는 <code>indexOf</code>메서드와 유사하게 작동하지만 배열의 뒤쪽에서부터 요소를 찾는다.</p>\n</li>\n<li><code>forEach(callback[, thisObject\\])</code> 메서드는 배열의 모든 요소에 대해 반복적으로 주어진 <code>callback</code> 함수를 실행한다. </li>\n<li>\n<p><code>map(callback[, thisObject\\])</code> 메서드는 배열의 모든 요소에 대해 콜백함수를 실행하고 콜백함수의 실행결과를 새로운 배열에 담아 반환한다.</p>\n<pre><code class=\"language-javascript\">var a1 = ['a', 'b', 'c'];\nvar a2 = a1.map(function(item) { return item.toUpperCase(); });\nconsole.log(a2); // logs ['A', 'B', 'C']\n</code></pre>\n</li>\n<li>\n<p><code>filter(callback[, thisObject\\])</code> 메서드는 배열의 모든 요소에 대해 콜백 함수가 true를 반환하는 요소를 새로운 배열에 담아 반환한다. </p>\n<pre><code class=\"language-javascript\">var a1 = ['a', 10, 'b', 20, 'c', 30];\nvar a2 = a1.filter(function(item) { return typeof item == 'number'; });\nconsole.log(a2); // logs ['10', '20', '30']\n</code></pre>\n</li>\n<li>\n<p><code>every (callback [, thisObject\\])</code> 는 콜백이 배열의 모든 항목에 대해 true를 반환하면 true를 반환한다.</p>\n<pre><code class=\"language-javascript\">function isNumber(value){\n  return typeof value == 'number';\n}\nvar a1 = [1, 2, 3];\nconsole.log(a1.every(isNumber)); // logs true\nvar a2 = [1, '2', 3];\nconsole.log(a2.every(isNumber)); // logs false\n</code></pre>\n</li>\n<li><code>some(callback[, thisObject\\])</code> 메서드는 배열의 모든 요소에 대해 콜백 함수를 실행하고 하나의 요소라도 콜백 함수의 결과가 true이면 some()메서드의 결과는 true가 된다.</li>\n<li>\n<p><code>reduce(callback[, initialValue\\])</code> 메서드는 배열 내의 요소를 하나의 요소로 줄이기 위해 <code>firstValue, secondValue</code>를 인자로 받는 콜백 함수를 실행한다.  </p>\n<p><code>reduceRight(callback[, initalvalue\\])</code> 메서드는 reduce()와 유사하게 작동하지만 배열의 마지막 요소부터 시작한다.  </p>\n<p><code>reduce</code>와 <code>reduceRight</code> 메서드는 반복적인 배열. 메서드 중 가장 명백하다. 두 메서드는 재귀적으로 하나의 시퀀스를 하나의 값으로 줄이기 위해 두개의 값을 합치는 알고리즘을 위해 사용되어야 한다. </p>\n<pre><code class=\"language-javascript\">var a = [10, 20, 30];\nvar total = a.reduce(function(first, second) { return first + second; }, 0);\nconsole.log(total) // Prints 60\n</code></pre>\n</li>\n</ol>\n<h2>key 기반의 Collections</h2>\n<h3>Map 객체</h3>\n<ul>\n<li>ECMAScript 6에서 값들을 매핑하기 위한 새로운 데이터 구조를 소개하고 있다.  그 중 하나인 Map객체는 간단한 키와 값을 서로 연결(매핑)시켜 저장하며 저장된 순서대로 각 요소들을 반복적으로 접근할 수 있도록 한다.</li>\n<li>\n<p>Map 객체에 저장되어 있는 각 요소들을 [키, 값] 형태의 배열로 반복적으로 반환해주는 <code>for...of</code> 를 사용할 수 있다.</p>\n<pre><code class=\"language-javascript\">var sayings = new Map();\nsayings.set(\"dog\", \"woof\");\nsayings.set(\"cat\", \"meow\");\n\nfor (var [key, value] of sayings) {\nconsole.log(key + \" goes \" + value);\n</code></pre>\n</li>\n<li>\n<p>Object와 Map 비교</p>\n<ul>\n<li>Object의 키는 <code>Strings</code>이며, Map의 키는 모든 값을 가질 수 있다.</li>\n<li>Object는 크기를 수동으로 추적해야하지만, Map은 크기를 쉽게 얻을 수 있다.</li>\n<li>Map은 삽입된 순서대로 반복된다.</li>\n<li>객체(Object)에는 prototype이 있고, Map에 기본 키들이 있다.</li>\n</ul>\n</li>\n<li>\n<p>Object와 Map 사용</p>\n<ul>\n<li>실행 시까지 키를 알 수 없고, 모든 키가 동일한 type이며 모든 값들이 동일한 type일 경우에는 objects를 대신해서 map을 사용하는 것이 좋다.</li>\n<li>각 개별 요소에 대해 적용해야 하는 로직이 있을 경우에는 objects를 사용하는 것이 좋다.</li>\n</ul>\n</li>\n</ul>\n<h3>Set 객체</h3>\n<ul>\n<li>Set 객체는 값들의 집합이다. 입력된 순서에따라 저장된 요소를 반복처리할 수 있다. </li>\n<li>\n<p>Set은 중복된 값을 허용하지 않는다. 따라서 특정 값은 Set내에서 하나만 존재하게 된다. </p>\n<pre><code class=\"language-javascript\">var mySet = new Set();\nmySet.add(1);\nmySet.add(\"some text\");\nmySet.add(\"foo\");\n\nmySet.has(1); // true\nmySet.delete(\"foo\");\nmySet.size; // 2\n\nfor (let item of mySet) console.log(item);\n</code></pre>\n</li>\n<li>\n<p>Array와 Set의 상호 변환</p>\n<ul>\n<li>Array.from 혹은 spread operator를 통해 Set 객체를 가지고 Array를 생성할 수 있다.</li>\n<li>또한 Set 생성자는 배열을 인자로 받을 수 있고 해당 배열을 Set객체의 요소로 저장한다. </li>\n<li>Set객체는 <strong>중복된 값을 저장하지 않기 때문에</strong> 주어진 배열내의 중복된 요소들을 제거되어 Set으로 변환된다.</li>\n</ul>\n<pre><code class=\"language-javascript\">Array.from(mySet);\n[...mySet2];\n\nmySet2 = new Set([1,2,3,4]);\n</code></pre>\n</li>\n<li>\n<p>Array와 Set 비교</p>\n<ul>\n<li>Set의 장점</li>\n<li><code>indexOf</code> 메서드를 사용하여 배열내에 특정 요소가 존재하는지 확인하는 것은 느리다.</li>\n<li>배열에선 해당 요소를 배열에서 잘라내야 하는 반면 Set 객체는 요소의 값으로 해당 요소를 삭제하는 기능 제공한다.</li>\n<li><code>NaN</code>은 배열에서 indexOf 메서드로 찾을 수 없다. </li>\n<li>Set 객체는 값의 유일성을 보장하기 때문에 직접 요소의 중복성을 확인할 필요가 없다. </li>\n</ul>\n</li>\n</ul>\n<h3>Map과 Set의 키와 값의 동치성</h3>\n<ul>\n<li>\n<p>Map 객체의 key에 대한 동치성 비교와 Set 객체의 값에 대한 동치성 비교 모두 <code>same-value-sero algorithm</code>에 근거한다.</p>\n<ul>\n<li>동치성 비교는 <code>===</code> 비교 연산과 같이 작동한다.</li>\n<li>-0과 +0은 같다고 간주한다.</li>\n<li><code>NaN</code>는 자기 자신하고 같다고 간주한다.</li>\n</ul>\n</li>\n</ul>\n<h2>References</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide\">MDN - JavaScript 안내서</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference\">MDN - JavaScript 참고서</a></li>\n</ul>","id":"c8b65dec-7fef-5ef0-a515-27ae182dff3e"},"allPosts":{"edges":[{"node":{"id":"7f695fca-e5ce-5c55-970b-e8855f99b61a"},"next":{"fields":{"slug":"/posts/java-script-1-개요/"},"frontmatter":{"title":"JavaScript (1) - 개요"}},"previous":null},{"node":{"id":"9f46ad6e-455d-53e9-8d4c-4794e5af39dd"},"next":{"fields":{"slug":"/posts/java-script-2-문법과-자료형/"},"frontmatter":{"title":"JavaScript (2) - 문법과 자료형"}},"previous":{"fields":{"slug":"/posts/hadoop/"},"frontmatter":{"title":"Hadoop"}}},{"node":{"id":"27ea8f29-94a3-5302-a637-efd0af842208"},"next":{"fields":{"slug":"/posts/java-script-3-제어흐름과-에러처리-loop-함수-표현식과-연산자-숫자와-날짜-텍스트-서식-정규-표현식/"},"frontmatter":{"title":"JavaScript (3) - 제어흐름과 에러처리, Loop, 함수, 표현식과 연산자, 숫자와 날짜, 텍스트 서식, 정규 표현식"}},"previous":{"fields":{"slug":"/posts/java-script-1-개요/"},"frontmatter":{"title":"JavaScript (1) - 개요"}}},{"node":{"id":"7470f1ce-f71d-5772-a8be-806ed3f7cc66"},"next":{"fields":{"slug":"/posts/java-script-4-loop와-반복-함수-표현식과-연산자-숫자와-날자-텍스트-서식-정규표현식/"},"frontmatter":{"title":"JavaScript (4) - Loop와 반복, 함수, 표현식과 연산자, 숫자와 날자, 텍스트 서식, 정규표현식"}},"previous":{"fields":{"slug":"/posts/java-script-2-문법과-자료형/"},"frontmatter":{"title":"JavaScript (2) - 문법과 자료형"}}},{"node":{"id":"c54308e0-d7a2-5d1c-b8ae-ecbfd04ed1ac"},"next":{"fields":{"slug":"/posts/java-script-5-collections/"},"frontmatter":{"title":"JavaScript (5) - Collections"}},"previous":{"fields":{"slug":"/posts/java-script-3-제어흐름과-에러처리-loop-함수-표현식과-연산자-숫자와-날짜-텍스트-서식-정규-표현식/"},"frontmatter":{"title":"JavaScript (3) - 제어흐름과 에러처리, Loop, 함수, 표현식과 연산자, 숫자와 날짜, 텍스트 서식, 정규 표현식"}}},{"node":{"id":"c8b65dec-7fef-5ef0-a515-27ae182dff3e"},"next":{"fields":{"slug":"/posts/java-script-6-objects/"},"frontmatter":{"title":"JavaScript (6) - Objects"}},"previous":{"fields":{"slug":"/posts/java-script-4-loop와-반복-함수-표현식과-연산자-숫자와-날자-텍스트-서식-정규표현식/"},"frontmatter":{"title":"JavaScript (4) - Loop와 반복, 함수, 표현식과 연산자, 숫자와 날자, 텍스트 서식, 정규표현식"}}},{"node":{"id":"6814abc2-41a1-520c-bd24-a8d2d02424fb"},"next":{"fields":{"slug":"/posts/java-script-7-반복기-및-생성기-메타-프로그래밍/"},"frontmatter":{"title":"JavaScript (7) - 반복기 및 생성기, 메타 프로그래밍"}},"previous":{"fields":{"slug":"/posts/java-script-5-collections/"},"frontmatter":{"title":"JavaScript (5) - Collections"}}},{"node":{"id":"2fa87adf-6f94-54db-a8e4-7ab4990ba5e6"},"next":{"fields":{"slug":"/posts/ci-cd/"},"frontmatter":{"title":"CI/CD"}},"previous":{"fields":{"slug":"/posts/java-script-6-objects/"},"frontmatter":{"title":"JavaScript (6) - Objects"}}},{"node":{"id":"2311c1d2-b785-582e-a9a9-d80750b5d505"},"next":{"fields":{"slug":"/posts/restful-api/"},"frontmatter":{"title":"Restful API"}},"previous":{"fields":{"slug":"/posts/java-script-7-반복기-및-생성기-메타-프로그래밍/"},"frontmatter":{"title":"JavaScript (7) - 반복기 및 생성기, 메타 프로그래밍"}}},{"node":{"id":"54319bda-39af-5fa4-9eee-7f84ee580c1a"},"next":{"fields":{"slug":"/posts/di와-자동-di/"},"frontmatter":{"title":"DI와 자동 DI"}},"previous":{"fields":{"slug":"/posts/ci-cd/"},"frontmatter":{"title":"CI/CD"}}},{"node":{"id":"443ae298-350d-531c-a42c-34e0acb0cdd8"},"next":{"fields":{"slug":"/posts/annotation/"},"frontmatter":{"title":"Annotation"}},"previous":{"fields":{"slug":"/posts/restful-api/"},"frontmatter":{"title":"Restful API"}}},{"node":{"id":"2e8c37a8-a44a-5356-b617-dc7b22034c2a"},"next":{"fields":{"slug":"/posts/spring-mvc-pattern/"},"frontmatter":{"title":"Spring MVC Pattern"}},"previous":{"fields":{"slug":"/posts/di와-자동-di/"},"frontmatter":{"title":"DI와 자동 DI"}}},{"node":{"id":"64980158-2ad8-5c44-91a8-a0185a6d4f6b"},"next":{"fields":{"slug":"/posts/orm과-jpa-2/"},"frontmatter":{"title":"ORM과 JPA (2)"}},"previous":{"fields":{"slug":"/posts/annotation/"},"frontmatter":{"title":"Annotation"}}},{"node":{"id":"5128821c-b701-5848-9979-bb91ec9c5836"},"next":{"fields":{"slug":"/posts/orm과-jpa-1/"},"frontmatter":{"title":"ORM과 JPA (1)"}},"previous":{"fields":{"slug":"/posts/spring-mvc-pattern/"},"frontmatter":{"title":"Spring MVC Pattern"}}},{"node":{"id":"d4549afd-0095-5810-b492-b843ca6e2f88"},"next":{"fields":{"slug":"/posts/apache-spark-2-rdd/"},"frontmatter":{"title":"Apache Spark (2) - RDD"}},"previous":{"fields":{"slug":"/posts/orm과-jpa-2/"},"frontmatter":{"title":"ORM과 JPA (2)"}}},{"node":{"id":"e46642ac-6d65-51b8-a535-21a9e3eabb56"},"next":{"fields":{"slug":"/posts/apache-spark-1-개요/"},"frontmatter":{"title":"Apache Spark (1) - 개요"}},"previous":{"fields":{"slug":"/posts/orm과-jpa-1/"},"frontmatter":{"title":"ORM과 JPA (1)"}}},{"node":{"id":"46426481-29ee-5d00-aa6c-cf05d52490f6"},"next":{"fields":{"slug":"/posts/동시성-처리/"},"frontmatter":{"title":"동시성 처리"}},"previous":{"fields":{"slug":"/posts/apache-spark-2-rdd/"},"frontmatter":{"title":"Apache Spark (2) - RDD"}}},{"node":{"id":"6eed9dfa-e294-5b19-a225-cd43d6cb982a"},"next":{"fields":{"slug":"/posts/erd/"},"frontmatter":{"title":"ERD"}},"previous":{"fields":{"slug":"/posts/apache-spark-1-개요/"},"frontmatter":{"title":"Apache Spark (1) - 개요"}}},{"node":{"id":"f016fc75-8476-5493-8ac1-e2862773f3e7"},"next":{"fields":{"slug":"/posts/git-사용법/"},"frontmatter":{"title":"Git 사용법"}},"previous":{"fields":{"slug":"/posts/동시성-처리/"},"frontmatter":{"title":"동시성 처리"}}},{"node":{"id":"9f5a9a91-7af6-5ca3-b20f-d6e177e46c68"},"next":{"fields":{"slug":"/posts/database/"},"frontmatter":{"title":"DATABASE"}},"previous":{"fields":{"slug":"/posts/erd/"},"frontmatter":{"title":"ERD"}}},{"node":{"id":"f77c8cbf-3a58-53fc-bd32-592702676a11"},"next":{"fields":{"slug":"/posts/jpa-1-query/"},"frontmatter":{"title":"JPA (1) - Query"}},"previous":{"fields":{"slug":"/posts/git-사용법/"},"frontmatter":{"title":"Git 사용법"}}},{"node":{"id":"b4e07799-70a4-523d-90ec-741e18230194"},"next":{"fields":{"slug":"/posts/jpa-2-specification/"},"frontmatter":{"title":"JPA (2) - Specification"}},"previous":{"fields":{"slug":"/posts/database/"},"frontmatter":{"title":"DATABASE"}}},{"node":{"id":"571df319-d1dd-59b6-a588-7a5db12c6b3d"},"next":{"fields":{"slug":"/posts/j-query/"},"frontmatter":{"title":"jQuery"}},"previous":{"fields":{"slug":"/posts/jpa-1-query/"},"frontmatter":{"title":"JPA (1) - Query"}}},{"node":{"id":"ef05bf06-2d53-5323-820b-98f46a906289"},"next":{"fields":{"slug":"/posts/kubernetes/"},"frontmatter":{"title":"Kubernetes"}},"previous":{"fields":{"slug":"/posts/jpa-2-specification/"},"frontmatter":{"title":"JPA (2) - Specification"}}},{"node":{"id":"a78eb59a-78b3-5c86-bcc2-f09ea58fab23"},"next":{"fields":{"slug":"/posts/node-js/"},"frontmatter":{"title":"NodeJS"}},"previous":{"fields":{"slug":"/posts/j-query/"},"frontmatter":{"title":"jQuery"}}},{"node":{"id":"3c37f3d1-7097-5528-a31b-12bcdcd937ab"},"next":{"fields":{"slug":"/posts/oop/"},"frontmatter":{"title":"OOP"}},"previous":{"fields":{"slug":"/posts/kubernetes/"},"frontmatter":{"title":"Kubernetes"}}},{"node":{"id":"fe690dd1-ec0c-544b-a44f-131d80987565"},"next":{"fields":{"slug":"/posts/postgre-sql-2-psql/"},"frontmatter":{"title":"PostgreSQL (2) - PSQL"}},"previous":{"fields":{"slug":"/posts/node-js/"},"frontmatter":{"title":"NodeJS"}}},{"node":{"id":"b8c8c26f-09bc-5759-8a7e-c81ffbc8f2c0"},"next":{"fields":{"slug":"/posts/postgre-sql-1-개요/"},"frontmatter":{"title":"PostgreSQL (1) - 개요"}},"previous":{"fields":{"slug":"/posts/oop/"},"frontmatter":{"title":"OOP"}}},{"node":{"id":"6268f141-e6af-5f89-a55b-2174ef57651f"},"next":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}},"previous":{"fields":{"slug":"/posts/postgre-sql-2-psql/"},"frontmatter":{"title":"PostgreSQL (2) - PSQL"}}},{"node":{"id":"1a663d51-139e-500f-a209-04faaebd2e85"},"next":{"fields":{"slug":"/posts/react-hook/"},"frontmatter":{"title":"React Hook"}},"previous":{"fields":{"slug":"/posts/postgre-sql-1-개요/"},"frontmatter":{"title":"PostgreSQL (1) - 개요"}}},{"node":{"id":"b227a2c1-7853-5450-a1be-f3e1c83307b4"},"next":{"fields":{"slug":"/posts/redux-react-redux/"},"frontmatter":{"title":"Redux & React-Redux"}},"previous":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}}},{"node":{"id":"80979747-a7b7-5e5d-81bb-30729e2e16bd"},"next":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}},"previous":{"fields":{"slug":"/posts/react-hook/"},"frontmatter":{"title":"React Hook"}}},{"node":{"id":"a82c048c-1eea-54e3-912d-ae875640e04e"},"next":{"fields":{"slug":"/posts/swagger/"},"frontmatter":{"title":"Swagger"}},"previous":{"fields":{"slug":"/posts/redux-react-redux/"},"frontmatter":{"title":"Redux & React-Redux"}}},{"node":{"id":"18c2a54b-1a71-511c-824c-f437be00f3ef"},"next":{"fields":{"slug":"/posts/tomcat-사용법/"},"frontmatter":{"title":"Tomcat 사용법"}},"previous":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}}},{"node":{"id":"d2056881-058f-5f23-88ec-cf613dff77f0"},"next":{"fields":{"slug":"/posts/web-rtc/"},"frontmatter":{"title":"WebRTC"}},"previous":{"fields":{"slug":"/posts/swagger/"},"frontmatter":{"title":"Swagger"}}},{"node":{"id":"d54a4c19-013d-538a-893d-ff8f62d34d7a"},"next":null,"previous":{"fields":{"slug":"/posts/tomcat-사용법/"},"frontmatter":{"title":"Tomcat 사용법"}}}]}},"pageContext":{"id":"c8b65dec-7fef-5ef0-a515-27ae182dff3e"}},"staticQueryHashes":["2001315320"]}