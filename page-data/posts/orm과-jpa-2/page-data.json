{"componentChunkName":"component---src-templates-single-post-js","path":"/posts/orm과-jpa-2/","result":{"data":{"post":{"frontmatter":{"meta":{"title":"test meta title","description":"test meta description","noindex":null,"canonicalLink":null},"title":"ORM과 JPA (2)","template":"SinglePost","subtitle":null,"date":"April 7th, 2020","categories":[{"category":"Spring"}]},"html":"<h2>ORM</h2>\n<ul>\n<li><strong>ORM</strong>(Object Relational Mapping)에서 가장 어려운 부분이 <code>객체 연관관계와 테이블 연관관계를 매핑</code>하는 일이다.  </li>\n<li>\n<p>연관관계를 매핑할 때 다음 <code>3가지</code>를 고려해야 한다.</p>\n<ol>\n<li>\n<p>방향(direction)</p>\n<ul>\n<li>단방향, 양방향 존재</li>\n<li>방향은 <code>객체 관계</code>에만 존재하고, 테이블은 항상 양방향</li>\n</ul>\n</li>\n<li>\n<p>다중성(multiplicity)</p>\n<ul>\n<li>다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M) 존재</li>\n</ul>\n</li>\n<li>\n<p>연관관계의 주인(owner)</p>\n<ul>\n<li>객체를 양방향 연관관계로 만들면 연관관계의 <code>주인</code>을 정해야 한다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3>객체 연관관계와 테이블 연관관계의 차이</h3>\n<ul>\n<li>\n<p>객체 연관관계는 <code>참조</code>를 사용한다.</p>\n<ul>\n<li>참조를 통한 연관관계는 언제나 <code>단방향</code>이다.</li>\n<li>객체간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 한다.</li>\n<li>\n<p>서로 다른 <code>단방향 관계가 2개</code>인 것  </p>\n<pre><code class=\"language-java\">// 단방향\nclass A {\nB b;\n}\nclass B {\n}\n</code></pre>\n</li>\n</ul>\n<p>// 양방향\nclass A {\nB b;\n}\nclass B {\nA a;\n}</p>\n<pre><code></code></pre>\n</li>\n<li>\n<p>테이블 연관관계는 <code>외래키</code>를 사용한다.</p>\n<ul>\n<li><code>조인</code>을 사용한다.</li>\n<li>\n<p>항상 <code>양방향</code>이다.  </p>\n<pre><code class=\"language-sql\">SELECT * FROM A JOIN B on A.b = B.b\nSELECT * FROM B JOIN A on A.b = B.b  \n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3>JPA를 사용하여 객체 연관관계와 테이블 연관관계 매핑</h3>\n<ul>\n<li>\n<p><code>@ManyToOne</code>: (N:1) 관계라는 매핑 정보이다.</p>\n<ul>\n<li>속성  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>기능</th>\n<th>기본값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>optional</td>\n<td>false로 설정하면 연관된 엔티티가 항상 있어야 한다.</td>\n<td>true</td>\n</tr>\n<tr>\n<td>fetch</td>\n<td>글로벌 페치전략</td>\n<td>@ManyToOne=FetchType.EAGER, @OneToMany=FetchType.LAZY</td>\n</tr>\n<tr>\n<td>cascade</td>\n<td>연속성 전이 기능</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>@ManyToOne의 로딩 방식</p>\n<ul>\n<li>EAGER (즉시 로딩): 연결된 엔티티 정보까지 한 번에 가져오기 때문에 성능 문제가 발생할 수 있다. (무한루프)</li>\n<li>LAZY (지연 로딩): proxy를 이용해서 데이터를 처리한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>@JoinColumn</code>: 외래 키를 매핑할 때 사용한다.</p>\n<ul>\n<li>속성   </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>기능</th>\n<th>기본값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>매핑할 외래 키 이름</td>\n<td>필드명 + _ + 참조하는 테이블의 기본키 컬럼명</td>\n</tr>\n<tr>\n<td>referencedColumnName</td>\n<td>외래키가 참조하는 대상 테이블의 컬럼명</td>\n<td>참조하는 테이블의 기본키 컬럼명</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>@JoinColumn을 생략하게 되면 기본 전략을 사용한다. (필드명<em>참조하는 테이블의 컬럼명. 예시: team</em>TEAM_ID)</li>\n</ul>\n</li>\n<li>\n<p><code>@OneToMany</code>: (1:N) 관계라는 매핑 정보이다.</p>\n<ul>\n<li><code>mappedBy 속성</code>은 <code>양방향</code> 매핑일 때 사용한다.</li>\n<li><code>연관관계의 주인</code>: 양방향 연관관계 매핑 시 외래키 관리자 (외래키가 있는 곳, 일대다 관계에서 다 쪽이 항상 주인이다.)</li>\n<li>단방향 연관관계가 2개이므로 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 한다.</li>\n<li>주인은 외래키 관리(등록, 수정, 삭제)가 가능하지만, 주인이 아니면 읽기만 할 수 있다.</li>\n<li>주인은 mappedBy 속성을 사용하지 않는다.</li>\n<li><code>주인이 아니면 mappedBy 속성을 사용해서 연관관계 주인을 지정해야 한다.</code> (mappedBy = \"연관관계 주인의 field값\")</li>\n</ul>\n</li>\n</ul>\n<h2>연관관계</h2>\n<ul>\n<li>\n<p>고려사항</p>\n<ol>\n<li>\n<p>다중성</p>\n<ul>\n<li>N:1(다대일, @ManyToOne)</li>\n<li>1:N(일대다, @OneToMany)</li>\n<li>1:1(일대일, @OneToOne)</li>\n<li>N:M(다대다, @ManyToMany)</li>\n</ul>\n</li>\n<li>단방향, 양방향</li>\n<li>연관관계의 주인</li>\n</ol>\n</li>\n</ul>\n<h3>1. 다대일 (N:1)</h3>\n<ul>\n<li>Member(N)와 Team(1)</li>\n</ul>\n<h4>1.1 다대일 단방향</h4>\n<ul>\n<li>Member (N) -> Team (1)</li>\n<li>\n<p>Member (N)  </p>\n<pre><code class=\"language-java\">@Entity\npublic class Member {\n\n    @Id\n    @Column(name = \"MEMBER_ID\")\n    private Long id;\n    private String username;\n\n    // 연관관계 매핑\n    @ManyToOne\n    @JoinColumn(name = \"TEAM_ID\")\n    private Team team;\n\n    // 연관관계 설정\n    public void setTeam(Team team) {\n        this.team = team;\n    }\n\n    ...\n}\n</code></pre>\n</li>\n<li>\n<p>Team (1)  </p>\n<pre><code class=\"language-java\">@Entity\npublic class Team {\n\n    @Id\n    @Column(name = \"TEAM_ID\")\n    private Long id;\n    private String name;\n\n    ...\n}\n</code></pre>\n</li>\n</ul>\n<h4>1.2 다대일 양방향</h4>\n<ul>\n<li>Member (N) &#x3C;-> Team (1)</li>\n<li>\n<p>Member (N)  </p>\n<pre><code class=\"language-java\">@Entity\npublic class Member {\n\n    @Id\n    @Column(name = \"MEMBER_ID\")\n    private Long id;\n    private String username;\n\n    // 연관관계 매핑\n    @ManyToOne\n    @JoinColumn(name = \"TEAM_ID\")\n    private Team team;\n\n    // 연관관계 편의 메소드\n    public void setTeam(Team team) {\n        this.team = team;\n\n        if(!team.getMembers().contains(this)){ // 무한루프에 빠지지 않도록 체크\n            team.getMembers().addthis();\n        }\n    }\n\n    ...\n}\n</code></pre>\n</li>\n<li>\n<p>Team (1)  </p>\n<pre><code class=\"language-java\">@Entity\npublic class Team {\n\n    @Id\n    @Column(name = \"TEAM_ID\")\n    private Long id;\n    private String name;\n\n    // 일대다 매핑\n    @OneToMany(mappedBy = \"team\")\n    private List&#x3C;Member> members = new ArrayList&#x3C;Member>();\n\n    // 연관관계 편의 메소드\n    public void addMember(Member member) {\n        this.members.add(member);\n\n        if(member.getTeam() != this){ // 무한루프에 빠지지 않도록 체크\n            member.setTeam(this);\n        }\n    }\n    ...\n}\n</code></pre>\n<ul>\n<li>mappedBy 속성에서 연관관계 주인인 Member의 field값 \"team\"을 지정한다.</li>\n<li>Collection, List, Set, Map 중에 하나를 사용한다.</li>\n</ul>\n</li>\n<li>\n<p>양방향 연관관계의 주의점</p>\n<ul>\n<li>연관관계 주인에 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하면 데이터베이스의 외래키에 정상적으로 저장되지 않는다.</li>\n<li>객체 관점에서 양쪽 방향 모두 값을 입력해주는 것이 안전하다. (JPA를 사용하지 않는 경우 문제 발생)</li>\n<li>\n<p>올바른 연관관계 설정    </p>\n<pre><code class=\"language-java\">// 연관관계 설정\npublic void setTeam(Team team) {\n\n// 기존 팀과 관계 제거\nif (this.team != null) {\n    this.team.getMembers().remove(this);\n}\nthis.team = team;\nteam.getMembers().addthis();\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3>2. 일대다 (1:N)</h3>\n<h4>2.1 일대다 단방향</h4>\n<ul>\n<li>\n<p>Team (1)  </p>\n<pre><code class=\"language-java\">@Entity\npublic class Team {\n\n    @Id\n    @Column(name = \"TEAM_ID\")\n    private Long id;\n    private String name;\n\n    // 일대다 매핑\n    @OneToMany\n    @JoinColumn(name = \"TEAM_ID\")\n    private List&#x3C;Member> members = new ArrayList&#x3C;Member>();\n\n    ...\n}\n</code></pre>\n</li>\n<li>\n<p>Member (N)  </p>\n<pre><code class=\"language-java\">@Entity\npublic class Member {\n\n    @Id\n    @Column(name = \"MEMBER_ID\")\n    private Long id;\n    private String username;\n\n    ...\n}\n</code></pre>\n</li>\n<li>\n<p>일대다 단방향 매핑의 단점</p>\n<ul>\n<li>매핑한 객체가 관리하는 외래키가 다른 테이블에 있다.</li>\n<li>다른 테이블에 외래키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야 한다.</li>\n<li>성능 및 관리 문제가 있으므로 <code>다대일 양방향 매핑을 사용하는 것이 좋다.</code></li>\n</ul>\n</li>\n</ul>\n<h4>2.2 일대다 양방향</h4>\n<ul>\n<li>\n<p>Team (1)  </p>\n<pre><code class=\"language-java\">@Entity\npublic class Team {\n\n    @Id\n    @Column(name = \"TEAM_ID\")\n    private Long id;\n    private String name;\n\n    // 일대다 매핑\n    @OneToMany\n    @JoinColumn(name = \"TEAM_ID\")\n    private List&#x3C;Member> members = new ArrayList&#x3C;Member>();\n\n    ...\n}\n</code></pre>\n</li>\n<li>\n<p>Member (N)  </p>\n<pre><code class=\"language-java\">@Entity\npublic class Member {\n\n    @Id\n    @Column(name = \"MEMBER_ID\")\n    private Long id;\n    private String username;\n\n    // 일대다 매핑\n    @ManyToOne\n    @JoinColumn(name = \"TEAM_ID\", insertable = false, updatable = false) // 읽기만 가능하도록 설정\n    private List&#x3C;Member> members = new ArrayList&#x3C;Member>();\n    ...\n}\n</code></pre>\n<ul>\n<li>양쪽에서 같은 키를 관리하므로 다 쪽은 읽기만 가능하도록 설정해야 한다.</li>\n<li>일대다 단방향 매핑의 단점을 그대로 가지므로 <code>다대일 양방향 매핑을 사용하는 것이 좋다.</code></li>\n</ul>\n</li>\n</ul>\n<h3>3. 일대일 (1:1)</h3>\n<ul>\n<li>일대일 관계는 어느 곳에나 외래키를 가질 수 있으므로 주 테이블과 대상 테이블 중 누가 외래키를 가질지 선택해야 한다.</li>\n<li>\n<p>주 테이블에 외래키 (객체 지향)</p>\n<ul>\n<li>외래키를 객체 참조와 비슷하게 사용할 수 있다.</li>\n<li>주 테이블만 확인하면 대상 테이블과 연관관계가 있는지 알 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>대상 테이블에 외래키</p>\n<ul>\n<li>일대일에서 일대다 관계로 변경할 때 테이블 구조를 그대로 유지할 수 있다.</li>\n<li>일대일 단방향 관계는 JPA에서 지원하지 않는다.</li>\n</ul>\n</li>\n</ul>\n<h4>3.1 주 테이블에 외래키</h4>\n<ul>\n<li>JPA의 경우 주 테이블에 외래키가 있으면 좀 더 편리하게 매핑할 수 있다.</li>\n<li>\n<p>단방향</p>\n<pre><code class=\"language-java\">@Entity\npublic class Member {\n\n    @Id\n    @GeneratedValue\n    @Column(name = \"MEMBER_ID\")\n    private Long id;\n    private String username;\n\n    @OneToOne\n    @JoinColumn(name = \"LOCKER_ID\")\n    private Locker locker;\n\n    ...\n}\n\n@Entity\npublic class Locker {\n\n    @Id\n    @GeneratedValue\n    @Column(name = \"LOCKER_ID\")\n    private Long id;\n    private String name;\n\n    ...\n}\n</code></pre>\n</li>\n<li>\n<p>양방향</p>\n<pre><code class=\"language-java\">@Entity\npublic class Member {\n\n    @Id\n    @GeneratedValue\n    @Column(name = \"MEMBER_ID\")\n    private Long id;\n    private String username;\n\n    @OneToOne\n    @JoinColumn(name = \"LOCKER_ID\")\n    private Locker locker;\n\n    ...\n}\n\n@Entity\npublic class Locker {\n\n    @Id\n    @GeneratedValue\n    @Column(name = \"LOCKER_ID\")\n    private Long id;\n    private String name;\n\n    @OneToOne(mappedBy = \"locker\")\n    private Member member;\n\n    ...\n}\n</code></pre>\n</li>\n</ul>\n<h4>3.2 대상 테이블에 외래키</h4>\n<ul>\n<li>단방향은 일대일 단방향 관계는 JPA에서 지원하지 않는다.</li>\n<li>\n<p>양방향    </p>\n<pre><code class=\"language-java\">@Entity\npublic class Member {\n\n    @Id\n    @GeneratedValue\n    @Column(name = \"MEMBER_ID\")\n    private Long id;\n    private String username;\n\n    @OneToOne(mappedBy = \"member\")\n    private Locker locker;\n\n    ...\n}\n\n@Entity\npublic class Locker {\n\n    @Id\n    @GeneratedValue\n    @Column(name = \"LOCKER_ID\")\n    private Long id;\n    private String name;\n\n    @OneToOne\n    @JoinColumn(name = \"MEMBER_ID\")\n    private Member member;\n\n    ...\n}\n</code></pre>\n</li>\n</ul>\n<h3>4. 다대다 (N:M)</h3>\n<ul>\n<li><code>관계형 데이터베이스</code>는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.</li>\n<li><code>연결 테이블</code>을 추가하여 일대다, 다대일 관계로 풀어내야 한다.  </li>\n<li><code>객체</code>는 테이블과 달리 객체 2개로 다대다 관계를 만들 수 있다.</li>\n</ul>\n<h4>4.1 다대다 단방향</h4>\n<ul>\n<li>\n<p>@JoinTable: 연결 테이블을 매핑한다.</p>\n<ul>\n<li>속성  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>기능</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@JoinTable.name</td>\n<td>연결 테이블을 지정한다.</td>\n</tr>\n<tr>\n<td>@JoinTable.joinColumns</td>\n<td>현재 방향에서 매핑할 조인 컬럼 정보를 지정한다.</td>\n</tr>\n<tr>\n<td>@JoinTable.inverseJoinColumns</td>\n<td>반대 방향에서 매핑할 조인 컬럼 정보를 지정한다.</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>Member -> Product (다대다 단방향)   </p>\n<pre><code class=\"language-java\">@Entity\npublic class Member {\n\n    @Id\n    @Column(name = \"MEMBER_ID\")\n    private Long id;\n    private String username;\n\n    @ManyToMany\n    @JoinTable(name = \"MEMBER_PRODUCT\", joinColums = @JoinColumn(name = \"MEMBER_ID\"), \n               inverseJoinColums = @JoinColumn(name = \"PRODUCT_ID\"))\n    private List&#x3C;Product> products = new ArrayList&#x3C;Product>();\n\n    ...\n}\n\n@Entity\npublic class Product {\n\n    @Id\n    @Column(name = \"PRODUCT_ID\")\n    private Long id;\n    private String name;\n\n    ...\n}\n</code></pre>\n</li>\n</ul>\n<h4>4.2 다대다 양방향</h4>\n<ul>\n<li>연관관계의 주인이 아닌 곳에 mappedBy로 주인을 지정한다.</li>\n<li>\n<p>Member &#x3C;-> Product (다대다 양방향)   </p>\n<pre><code class=\"language-java\">@Entity\npublic class Member {\n\n    @Id\n    @Column(name = \"MEMBER_ID\")\n    private Long id;\n    private String username;\n\n    @ManyToMany\n    @JoinTable(name = \"MEMBER_PRODUCT\", joinColums = @JoinColumn(name = \"MEMBER_ID\"), \n               inverseJoinColums = @JoinColumn(name = \"PRODUCT_ID\"))\n    private List&#x3C;Product> products = new ArrayList&#x3C;Product>();\n\n    ...\n}\n\n@Entity\npublic class Product {\n\n    @Id\n    @Column(name = \"PRODUCT_ID\")\n    private Long id;\n    private String name;\n\n    // 역방향 추가\n    @ManyToMany(mappedBy = \"products\")\n    private List&#x3C;Member> members;\n\n    ...\n}\n</code></pre>\n<ul>\n<li>MEMBER_PRODUCT 테이블은 다대다 관계를 일대다, 다대일 관계로 풀어내기 위한 <code>연결 테이블</code>이다.</li>\n</ul>\n</li>\n</ul>\n<h4>4.3 다대다 매핑의 한계와 극복, 연결 엔티티 사용</h4>\n<ul>\n<li>@ManyToMany를 사용하면 연결 테이블을 자동으로 처리해주므로 도메인 모델이 단순해지고 편리하다.</li>\n<li>한계: 연결 테이블에 새로운 컬럼을 추가할 경우 @ManyToMany를 사용할 수 없다.</li>\n<li>해결 방법: 엔티티 간의 관계도 다대다에서 일대다, 다대일 관계로 풀어야 한다.  </li>\n<li>\n<p>Member -일대다- MemberProduct -다대일- Product</p>\n<pre><code class=\"language-java\">@Entity\npublic class Member {\n\n    @Id\n    @Column(name = \"MEMBER_ID\")\n    private Long id;\n    private String username;\n\n    @OneToMany(mappedBy = \"member\")\n    private List&#x3C;MemberProduct> memberproducts;\n\n    ...\n}\n\n@Entity\npublic class Product {\n\n    @Id\n    @Column(name = \"PRODUCT_ID\")\n    private Long id;\n    private String name;\n\n    ...\n}\n\n// 복합 기본키\n@Entity\n@IdClass(MemberProductId.class)\npublic class MemberProduct {\n    \n    // 기본키+외래키\n    @Id\n    @ManyToOne\n    @JoinColumn(name = \"MEMBER_ID\")\n    private Member member; // MemberProductId.member와 연결\n\n    // 기본키+외래키\n    @Id\n    @ManyToOne\n    @JoinColumn(name = \"PRODUCT_ID\")\n    private Product product; // MemberProductId.product와 연결\n\n    private int orderAmount;\n\n    ...\n}\n</code></pre>\n<ul>\n<li>기본키를 매핑하는 @Id와 외래키를 매핑하는 @JoinColumn을 동시에 사용해서 기본키+외래키를 한번에 매핑한다.</li>\n<li>\n<p>@IdClass를 사용해서 복합 기본키를 매핑한다.  </p>\n<pre><code class=\"language-java\">// 식별자 클래스\npublic class MemberProductId implements Serializable {\n\nprivate String member; // MemberProduct.member와 연결\nprivate String product; // MemberProduct.product와 연결\n\n// hashCode and equals\n\n@Override\npublic boolean equals(Object o) {...}\n\n@Override\npublic int hashCode() {...}\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>복합 기본키</p>\n<ul>\n<li>JPA에서 복합키를 사용하려면 별도의 식별자 클래스를 만들어야 한다.</li>\n<li>@IdClass를 사용해서 식별자 클래스를 지정한다.</li>\n<li>\n<p>복합키를 위한 식별자 클래스의 <code>특징</code></p>\n<ul>\n<li>복합키는 별도의 식별자 클래스로 만들어야 한다.</li>\n<li>Serializable을 구현해야 한다.</li>\n<li>equals와 hashCode 메소드를 구현해야 한다.</li>\n<li>기본 생성자가 있어야 한다.</li>\n<li>식별자 클래스는 public이어야 한다.</li>\n<li>@IdClass를 사용하는 방법 외에 @EmbeddedId를 사용하는 방법도 있다.<br>\n(* JAVA IDE에는 대부분 equals, hashCode 메소드를 자동으로 생성해주는 기능이 있다.)  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>식별 관계</p>\n<ul>\n<li>부모 테이블의 기본키를 받아서 자신의 기본키+외래키로 사용하는 것을 데이터베이스 용어로 <code>식별 관계</code>라 한다.</li>\n</ul>\n</li>\n</ul>\n<h4>4.4 다대다: 새로운 기본키 사용</h4>\n<ul>\n<li>기본키 생성 전략은 데이터베이스에서 자동으로 생성해주는 대리키를 Long값으로 사용하는 것이다.</li>\n<li>간편하고 거의 영구적으로 사용할 수 있으며, 비즈니스에 의존하지 않는다는 장점이 있다.</li>\n<li>ORM 매핑 시 복합키를 만들지 않아도 되므로 간단히 매핑을 완성할 수 있다.</li>\n<li>\n<p>연결 테이블에 새로운 기본키 사용 (MemberProduct가 아닌 Order 이름 사용)  </p>\n<pre><code class=\"language-java\">@Entity\npublic class Order {\n\n    // 새로운 식별자\n    @Id\n    @GeneratedValue\n    @Column(name = \"ORDER_ID\")\n    private Long id;\n\n    // 외래키\n    @ManyToOne\n    @JoinColumn(name = \"MEMBER_ID\")\n    private Member member;\n\n    // 외래키\n    @ManyToOne\n    @JoinColumn(name = \"PRODUCT_ID\")\n    private Product product;\n\n    private int orderAmount;\n\n    ...\n}\n</code></pre>\n<ul>\n<li>대리키를 사용함으로써 이전에 보았던 식별 관계에 복합키를 사용한느 것보다 매핑이 단순하고 이해하기 쉽다.</li>\n</ul>\n</li>\n</ul>\n<h4>4.5 다대다 연관관계 정리</h4>\n<ul>\n<li>\n<p>다대다 관계를 일대다, 다대일 관계로 풀어내기 위해 연결 테이블을 만들 때 <code>식별자</code>를 어떻게 구성할지 선택해야 한다.</p>\n<ul>\n<li><code>식별 관계</code>: 받아온 식별자를 기본키+외래키로 사용한다.</li>\n<li><code>비식별 관계</code>: 받아온 식별자는 외래키로만 사용하고 새로운 식별자를 추가한다.</li>\n</ul>\n</li>\n<li><code>비식별 관계</code>를 사용하는 것이 복합키를 위한 식별자 클래스를 만들지 않아도 되므로 단순하고 편리하게 ORM 매핑을 할 수 있다.</li>\n</ul>","id":"5128821c-b701-5848-9979-bb91ec9c5836"},"allPosts":{"edges":[{"node":{"id":"7f695fca-e5ce-5c55-970b-e8855f99b61a"},"next":{"fields":{"slug":"/posts/java-script-1-개요/"},"frontmatter":{"title":"JavaScript (1) - 개요"}},"previous":null},{"node":{"id":"9f46ad6e-455d-53e9-8d4c-4794e5af39dd"},"next":{"fields":{"slug":"/posts/java-script-2-문법과-자료형/"},"frontmatter":{"title":"JavaScript (2) - 문법과 자료형"}},"previous":{"fields":{"slug":"/posts/hadoop/"},"frontmatter":{"title":"Hadoop"}}},{"node":{"id":"27ea8f29-94a3-5302-a637-efd0af842208"},"next":{"fields":{"slug":"/posts/java-script-3-제어흐름과-에러처리-loop-함수-표현식과-연산자-숫자와-날짜-텍스트-서식-정규-표현식/"},"frontmatter":{"title":"JavaScript (3) - 제어흐름과 에러처리, Loop, 함수, 표현식과 연산자, 숫자와 날짜, 텍스트 서식, 정규 표현식"}},"previous":{"fields":{"slug":"/posts/java-script-1-개요/"},"frontmatter":{"title":"JavaScript (1) - 개요"}}},{"node":{"id":"7470f1ce-f71d-5772-a8be-806ed3f7cc66"},"next":{"fields":{"slug":"/posts/java-script-4-loop와-반복-함수-표현식과-연산자-숫자와-날자-텍스트-서식-정규표현식/"},"frontmatter":{"title":"JavaScript (4) - Loop와 반복, 함수, 표현식과 연산자, 숫자와 날자, 텍스트 서식, 정규표현식"}},"previous":{"fields":{"slug":"/posts/java-script-2-문법과-자료형/"},"frontmatter":{"title":"JavaScript (2) - 문법과 자료형"}}},{"node":{"id":"c54308e0-d7a2-5d1c-b8ae-ecbfd04ed1ac"},"next":{"fields":{"slug":"/posts/java-script-5-collections/"},"frontmatter":{"title":"JavaScript (5) - Collections"}},"previous":{"fields":{"slug":"/posts/java-script-3-제어흐름과-에러처리-loop-함수-표현식과-연산자-숫자와-날짜-텍스트-서식-정규-표현식/"},"frontmatter":{"title":"JavaScript (3) - 제어흐름과 에러처리, Loop, 함수, 표현식과 연산자, 숫자와 날짜, 텍스트 서식, 정규 표현식"}}},{"node":{"id":"c8b65dec-7fef-5ef0-a515-27ae182dff3e"},"next":{"fields":{"slug":"/posts/java-script-6-objects/"},"frontmatter":{"title":"JavaScript (6) - Objects"}},"previous":{"fields":{"slug":"/posts/java-script-4-loop와-반복-함수-표현식과-연산자-숫자와-날자-텍스트-서식-정규표현식/"},"frontmatter":{"title":"JavaScript (4) - Loop와 반복, 함수, 표현식과 연산자, 숫자와 날자, 텍스트 서식, 정규표현식"}}},{"node":{"id":"6814abc2-41a1-520c-bd24-a8d2d02424fb"},"next":{"fields":{"slug":"/posts/java-script-7-반복기-및-생성기-메타-프로그래밍/"},"frontmatter":{"title":"JavaScript (7) - 반복기 및 생성기, 메타 프로그래밍"}},"previous":{"fields":{"slug":"/posts/java-script-5-collections/"},"frontmatter":{"title":"JavaScript (5) - Collections"}}},{"node":{"id":"2fa87adf-6f94-54db-a8e4-7ab4990ba5e6"},"next":{"fields":{"slug":"/posts/ci-cd/"},"frontmatter":{"title":"CI/CD"}},"previous":{"fields":{"slug":"/posts/java-script-6-objects/"},"frontmatter":{"title":"JavaScript (6) - Objects"}}},{"node":{"id":"2311c1d2-b785-582e-a9a9-d80750b5d505"},"next":{"fields":{"slug":"/posts/restful-api/"},"frontmatter":{"title":"Restful API"}},"previous":{"fields":{"slug":"/posts/java-script-7-반복기-및-생성기-메타-프로그래밍/"},"frontmatter":{"title":"JavaScript (7) - 반복기 및 생성기, 메타 프로그래밍"}}},{"node":{"id":"54319bda-39af-5fa4-9eee-7f84ee580c1a"},"next":{"fields":{"slug":"/posts/di와-자동-di/"},"frontmatter":{"title":"DI와 자동 DI"}},"previous":{"fields":{"slug":"/posts/ci-cd/"},"frontmatter":{"title":"CI/CD"}}},{"node":{"id":"443ae298-350d-531c-a42c-34e0acb0cdd8"},"next":{"fields":{"slug":"/posts/annotation/"},"frontmatter":{"title":"Annotation"}},"previous":{"fields":{"slug":"/posts/restful-api/"},"frontmatter":{"title":"Restful API"}}},{"node":{"id":"2e8c37a8-a44a-5356-b617-dc7b22034c2a"},"next":{"fields":{"slug":"/posts/spring-mvc-pattern/"},"frontmatter":{"title":"Spring MVC Pattern"}},"previous":{"fields":{"slug":"/posts/di와-자동-di/"},"frontmatter":{"title":"DI와 자동 DI"}}},{"node":{"id":"64980158-2ad8-5c44-91a8-a0185a6d4f6b"},"next":{"fields":{"slug":"/posts/orm과-jpa-2/"},"frontmatter":{"title":"ORM과 JPA (2)"}},"previous":{"fields":{"slug":"/posts/annotation/"},"frontmatter":{"title":"Annotation"}}},{"node":{"id":"5128821c-b701-5848-9979-bb91ec9c5836"},"next":{"fields":{"slug":"/posts/orm과-jpa-1/"},"frontmatter":{"title":"ORM과 JPA (1)"}},"previous":{"fields":{"slug":"/posts/spring-mvc-pattern/"},"frontmatter":{"title":"Spring MVC Pattern"}}},{"node":{"id":"d4549afd-0095-5810-b492-b843ca6e2f88"},"next":{"fields":{"slug":"/posts/apache-spark-2-rdd/"},"frontmatter":{"title":"Apache Spark (2) - RDD"}},"previous":{"fields":{"slug":"/posts/orm과-jpa-2/"},"frontmatter":{"title":"ORM과 JPA (2)"}}},{"node":{"id":"e46642ac-6d65-51b8-a535-21a9e3eabb56"},"next":{"fields":{"slug":"/posts/apache-spark-1-개요/"},"frontmatter":{"title":"Apache Spark (1) - 개요"}},"previous":{"fields":{"slug":"/posts/orm과-jpa-1/"},"frontmatter":{"title":"ORM과 JPA (1)"}}},{"node":{"id":"46426481-29ee-5d00-aa6c-cf05d52490f6"},"next":{"fields":{"slug":"/posts/동시성-처리/"},"frontmatter":{"title":"동시성 처리"}},"previous":{"fields":{"slug":"/posts/apache-spark-2-rdd/"},"frontmatter":{"title":"Apache Spark (2) - RDD"}}},{"node":{"id":"6eed9dfa-e294-5b19-a225-cd43d6cb982a"},"next":{"fields":{"slug":"/posts/erd/"},"frontmatter":{"title":"ERD"}},"previous":{"fields":{"slug":"/posts/apache-spark-1-개요/"},"frontmatter":{"title":"Apache Spark (1) - 개요"}}},{"node":{"id":"f016fc75-8476-5493-8ac1-e2862773f3e7"},"next":{"fields":{"slug":"/posts/git-사용법/"},"frontmatter":{"title":"Git 사용법"}},"previous":{"fields":{"slug":"/posts/동시성-처리/"},"frontmatter":{"title":"동시성 처리"}}},{"node":{"id":"9f5a9a91-7af6-5ca3-b20f-d6e177e46c68"},"next":{"fields":{"slug":"/posts/database/"},"frontmatter":{"title":"DATABASE"}},"previous":{"fields":{"slug":"/posts/erd/"},"frontmatter":{"title":"ERD"}}},{"node":{"id":"f77c8cbf-3a58-53fc-bd32-592702676a11"},"next":{"fields":{"slug":"/posts/jpa-1-query/"},"frontmatter":{"title":"JPA (1) - Query"}},"previous":{"fields":{"slug":"/posts/git-사용법/"},"frontmatter":{"title":"Git 사용법"}}},{"node":{"id":"b4e07799-70a4-523d-90ec-741e18230194"},"next":{"fields":{"slug":"/posts/jpa-2-specification/"},"frontmatter":{"title":"JPA (2) - Specification"}},"previous":{"fields":{"slug":"/posts/database/"},"frontmatter":{"title":"DATABASE"}}},{"node":{"id":"571df319-d1dd-59b6-a588-7a5db12c6b3d"},"next":{"fields":{"slug":"/posts/j-query/"},"frontmatter":{"title":"jQuery"}},"previous":{"fields":{"slug":"/posts/jpa-1-query/"},"frontmatter":{"title":"JPA (1) - Query"}}},{"node":{"id":"ef05bf06-2d53-5323-820b-98f46a906289"},"next":{"fields":{"slug":"/posts/kubernetes/"},"frontmatter":{"title":"Kubernetes"}},"previous":{"fields":{"slug":"/posts/jpa-2-specification/"},"frontmatter":{"title":"JPA (2) - Specification"}}},{"node":{"id":"a78eb59a-78b3-5c86-bcc2-f09ea58fab23"},"next":{"fields":{"slug":"/posts/node-js/"},"frontmatter":{"title":"NodeJS"}},"previous":{"fields":{"slug":"/posts/j-query/"},"frontmatter":{"title":"jQuery"}}},{"node":{"id":"3c37f3d1-7097-5528-a31b-12bcdcd937ab"},"next":{"fields":{"slug":"/posts/oop/"},"frontmatter":{"title":"OOP"}},"previous":{"fields":{"slug":"/posts/kubernetes/"},"frontmatter":{"title":"Kubernetes"}}},{"node":{"id":"fe690dd1-ec0c-544b-a44f-131d80987565"},"next":{"fields":{"slug":"/posts/postgre-sql-2-psql/"},"frontmatter":{"title":"PostgreSQL (2) - PSQL"}},"previous":{"fields":{"slug":"/posts/node-js/"},"frontmatter":{"title":"NodeJS"}}},{"node":{"id":"b8c8c26f-09bc-5759-8a7e-c81ffbc8f2c0"},"next":{"fields":{"slug":"/posts/postgre-sql-1-개요/"},"frontmatter":{"title":"PostgreSQL (1) - 개요"}},"previous":{"fields":{"slug":"/posts/oop/"},"frontmatter":{"title":"OOP"}}},{"node":{"id":"6268f141-e6af-5f89-a55b-2174ef57651f"},"next":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}},"previous":{"fields":{"slug":"/posts/postgre-sql-2-psql/"},"frontmatter":{"title":"PostgreSQL (2) - PSQL"}}},{"node":{"id":"1a663d51-139e-500f-a209-04faaebd2e85"},"next":{"fields":{"slug":"/posts/react-hook/"},"frontmatter":{"title":"React Hook"}},"previous":{"fields":{"slug":"/posts/postgre-sql-1-개요/"},"frontmatter":{"title":"PostgreSQL (1) - 개요"}}},{"node":{"id":"b227a2c1-7853-5450-a1be-f3e1c83307b4"},"next":{"fields":{"slug":"/posts/redux-react-redux/"},"frontmatter":{"title":"Redux & React-Redux"}},"previous":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}}},{"node":{"id":"80979747-a7b7-5e5d-81bb-30729e2e16bd"},"next":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}},"previous":{"fields":{"slug":"/posts/react-hook/"},"frontmatter":{"title":"React Hook"}}},{"node":{"id":"a82c048c-1eea-54e3-912d-ae875640e04e"},"next":{"fields":{"slug":"/posts/swagger/"},"frontmatter":{"title":"Swagger"}},"previous":{"fields":{"slug":"/posts/redux-react-redux/"},"frontmatter":{"title":"Redux & React-Redux"}}},{"node":{"id":"18c2a54b-1a71-511c-824c-f437be00f3ef"},"next":{"fields":{"slug":"/posts/tomcat-사용법/"},"frontmatter":{"title":"Tomcat 사용법"}},"previous":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}}},{"node":{"id":"d2056881-058f-5f23-88ec-cf613dff77f0"},"next":{"fields":{"slug":"/posts/web-rtc/"},"frontmatter":{"title":"WebRTC"}},"previous":{"fields":{"slug":"/posts/swagger/"},"frontmatter":{"title":"Swagger"}}},{"node":{"id":"d54a4c19-013d-538a-893d-ff8f62d34d7a"},"next":null,"previous":{"fields":{"slug":"/posts/tomcat-사용법/"},"frontmatter":{"title":"Tomcat 사용법"}}}]}},"pageContext":{"id":"5128821c-b701-5848-9979-bb91ec9c5836"}},"staticQueryHashes":["2001315320"]}