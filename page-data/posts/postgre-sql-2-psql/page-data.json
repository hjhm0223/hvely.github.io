{"componentChunkName":"component---src-templates-single-post-js","path":"/posts/postgre-sql-2-psql/","result":{"data":{"post":{"frontmatter":{"meta":{"title":"test meta title","description":"test meta description","noindex":null,"canonicalLink":null},"title":"PostgreSQL (2) - PSQL","template":"SinglePost","subtitle":null,"date":"April 1st, 2020","categories":[{"category":"DataBase"}]},"html":"<p><img src=\"https://t1.daumcdn.net/cfile/tistory/99AE574A5C49905F20\" alt=\"postgresql\"></p>\n<p>(*postgre 9.4 ver document)  </p>\n<h2>PostgreSQL 기본 구조</h2>\n<p>PostgreSQL은 클라이언트/서버 모델을 사용하고 있다. 하나의 PostgreSQL 세션(작업)은 다음과 같은 프로세스들의 상호 작동으로 구성된다.</p>\n<ul>\n<li>서버 프로세스<br>\n데이터베이스 파일을 관리하고 클라이언트 응용 프로그램들이 서버에 연결을 요청할 때 그 요청들을 처리하고, 클라이언트들이 데이터베이스를 사용할 수 있도록 기반 작업들을 준비한다.</li>\n<li>클라이언트 프로세스<br>\n데이터베이스를 사용하려는 사용자 측 응용 프로그램으로 클매우 다양한 형태를 띄고 있다. 어떤 것은 텍스트 기반의 프로그램, 그래픽 응용 프로그램이며, 웹서버를 통해서 웹페이지로 보여지기도 한다. </li>\n</ul>\n<h2>데이터베이스 사용하기</h2>\n<h3>데이터베이스 만들기</h3>\n<pre><code class=\"language-cmd\"># mydb라는 이름의 새로운 데이터베이스 만들기\n$ createdb mydb\n\n# \"command not found\" 메시지 나올 경우 환경변수 설정 필요\n</code></pre>\n<h3>psql 사용하기</h3>\n<p><a href=\"https://postgresql.kr/docs/9.4/tutorial-accessdb.html\">https://postgresql.kr/docs/9.4/tutorial-accessdb.html</a></p>\n<h2>SQL 언어</h2>\n<p>PostgreSQL은 관계형 데이터베이스 관리 시스템(RDBMS, relational database management system)이다. 즉, 관계들로 구성된 자료를 관리하기 위한 시스템이다. 테이블은 <code>데이터베이스</code> 안에 속하고, 이 데이터베이스들의 모음을 하나의 <code>PostgreSQL 서버</code>가 관리한다. 그리고 하나의 서버가 관리하는 데이터베이스 집합 단위를 <code>클러스터</code>라 한다.</p>\n<h3>새 테이블 생성</h3>\n<p>테이블 이름과 테이블을 구성하는 각 칼럼, 칼럼의 자료형을 지정해서 생성한다.  </p>\n<pre><code class=\"language-cmd\">CREATE TABLE weather (\n    city            varchar(80),\n    temp_lo         int,           -- low temperature\n    temp_hi         int,           -- high temperature\n    prcp            real,          -- precipitation\n    date            date\n);\n</code></pre>\n<ul>\n<li>예약어(keyword, 명령이름, 구문 중간 중간에 나오는 on, default, not null 같은 것들)와 식별자(identifier, 테이블 이름, 칼럼 이름 같은 것들)의 <code>대소문자를 구별하지 않지만</code>, 식별자가 큰따옴표(\") 안에 쓰이면 <code>대소문자를 그대로 유지</code>한다.</li>\n<li><code>표준 SQL 자료형인 int, smallint, real, double precision, char(N), varchar(N), date, time, timestamp, interval형</code>을 사용할 수 있으며, 기타 자료형들과 지리 정보를 담는 다양한 자료형을 사용할 수 있다.</li>\n</ul>\n<h3>테이블 삭제</h3>\n<pre><code class=\"language-cmd\">DROP TABLE 테이블이름;\n</code></pre>\n<h3>테이블에 자료 입력하기</h3>\n<p>특정 테이블에 자료를 입력할 때는 <code>INSERT 구문</code>이 사용된다.  </p>\n<pre><code class=\"language-cmd\">INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');\n</code></pre>\n<ul>\n<li>각 칼럼의 실제 자료들은 테이블을 생성할 때 지정한 자료형과 완벽하게 일치해야 한다.</li>\n<li>숫자가 아닌 자료일 경우는 작은 따옴표(')로 둘러쌓아야한다. 날짜형 자료를 입력할 경우는 그 값이 정확하게 날짜 표현 형식이어야 한다. </li>\n<li>\n<p>point 자료형은 다음과 같이 하나의 쌍으로 입력되어야 한다.  </p>\n<pre><code class=\"language-cmd\">INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');\n</code></pre>\n</li>\n<li>\n<p>각 칼럼의 입력 순서를 사용자가 지정할 수 있다.  </p>\n<pre><code class=\"language-cmd\">INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)\n  VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');\n</code></pre>\n</li>\n<li>\n<p>대용량의 데이터를 빠르게 입력해야할 때 <code>COPY</code> 명령을 사용한다. 이 때 지정한 파일은 서버가 가동 중인 호스트에 있어야 한다. 접속한 서버가 원격호스트라면 파일을 원격호스트에서 찾는다.  </p>\n<pre><code class=\"language-cmd\">COPY weather FROM '/home/user/weather.txt';\n</code></pre>\n</li>\n</ul>\n<h3>테이블 자료 조회하기</h3>\n<p>입력한 자료를 찾기 위해 테이블을 검색하는 것을 <code>쿼리</code>라 하고, <code>SELECT</code> 구문을 사용한다.<br>\n이 구문은 크게 세 부분으로 구성되는데, 원하는 자료의 칼럼들을 지정하고, 그 칼럼들이 있는 테이블을 from 절이라 하고, 원하는 부분을 지정하는 where 조건절이라 한다.   </p>\n<pre><code class=\"language-cmd\">SELECT * FROM weather;\n\nSELECT * FROM weather\n    WHERE city = 'San Francisco' AND prcp > 0.0;\n</code></pre>\n<ul>\n<li>where 절이 생략되면 지정한 테이블의 모든 자료를 보여준다.</li>\n<li>WHERE절에 사용할 조건은 boolean 조건들의 집합으로 구성된다. 일반적으로 boolean 연산자(AND, OR, NOT)을 이용해서 WHERE절 전체의 조건을 구성한다.</li>\n<li>\n<p>출력 순서를 바꾸고 싶으면 <code>정렬 조건</code>을 추가한다.  </p>\n<pre><code class=\"language-cmd\">SELECT * FROM weather ORDER BY city;\n\nSELECT * FROM weather ORDER BY city, temp_lo;\n</code></pre>\n</li>\n<li>\n<p>같은 값에 대한 중복을 없애려면 <code>DISTINCT</code>을 사용한다.  </p>\n<pre><code class=\"language-cmd\">SELECT DISTINCT city FROM weather ORDER BY city;\n</code></pre>\n</li>\n</ul>\n<h3>테이블 조인</h3>\n<p>하나 이상의 테이블, 뷰, SELECT 구문으로 만들어진 특정 row들, 서버 함수의 리턴 값 등을 같이 연결해서 자료를 뽑아내는 것을 <code>JOIN</code>이라 한다.  </p>\n<pre><code class=\"language-cmd\">SELECT * FROM weather, cities WHERE city = name;\n\n# 결과\n     city      | temp_lo | temp_hi | prcp |    date    |     name      | location\n---------------+---------+---------+------+------------+---------------+-----------\n San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)\n San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)\n(2 rows)\n</code></pre>\n<ul>\n<li>이 결과에서는 Hayward 도시 정보가 빠져있다. 이것은 cities 테이블에 이 도시에 대한 정보가 빠져있기 때문이다. 즉, 윗 구문에서는 where 절 다음에 오는 조건에 일치하는 자료들만 보이게 된다. </li>\n<li>다른 하나는 도시 이름이 두개가 보이는 것이다. 잘못된 결과가 아니라, 출력 칼럼을 지정하는 곳에서 * 문자를 사용해서 모든 칼럼을 보겠다고 했으니, weather 테이블과 cities 테이블에 있는 각각의 도시 이름이 모두 보이게 된 것이다.</li>\n<li>\n<p><code>지정자(qualify)</code>를 사용하여 컬럼 이름이 같을 경우를 대비한다.  </p>\n<pre><code class=\"language-cmd\">SELECT weather.city, weather.temp_lo, weather.temp_hi,\n    weather.prcp, weather.date, cities.location\n  FROM weather, cities\n  WHERE cities.name = weather.city;\n</code></pre>\n</li>\n<li>\n<p>INNER JOIN 구문  </p>\n<pre><code class=\"language-cmd\">SELECT *\n  FROM weather INNER JOIN cities ON (weather.city = cities.name);\n</code></pre>\n</li>\n<li>\n<p>OUTER JOIN 구문  </p>\n<pre><code class=\"language-cmd\">SELECT *\n  FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);\n\n# 결과\n  city      | temp_lo | temp_hi | prcp |    date    |     name      | location\n---------------+---------+---------+------+------------+---------------+-----------\nHayward       |      37 |      54 |      | 1994-11-29 |               |\nSan Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)\nSan Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)\n(3 rows)\n</code></pre>\n</li>\n<li>\n<p>하나의 테이블을 연결하는 경우 <code>self join 구문</code>을 사용한다.  </p>\n<pre><code class=\"language-cmd\"># 현재 행의 최저기온이 다른 행의 최저기온보다 더 낮고, 최고 기온이 다른 행의 최고기온보다 높은 경우의 행을 출력\nSELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,\n  W2.city, W2.temp_lo AS low, W2.temp_hi AS high\n  FROM weather W1, weather W2\n  WHERE W1.temp_lo &#x3C; W2.temp_lo\n  AND W1.temp_hi > W2.temp_hi;\n\n# 결과\n  city      | low | high |     city      | low | high\n---------------+-----+------+---------------+-----+------\nSan Francisco |  43 |   57 | San Francisco |  46 |   50\nHayward       |  37 |   54 | San Francisco |  46 |   50\n(2 rows)\n</code></pre>\n</li>\n</ul>\n<h3>집계 함수</h3>\n<p>집계 함수(Aggregate Function)이란 입력이 여러 개의 행이고, 출력이 하나인 결과를 말한다. 테이블의 전체 row 수를 구하는 count, 평균(avg), 총합(sum), 최대값(max), 최소값(min) 등의 함수를 말한다.  </p>\n<pre><code class=\"language-cmd\">SELECT max(temp_lo) FROM weather;\n\n# 결과\n max\n-----\n  46\n(1 row)\n</code></pre>\n<ul>\n<li>\n<p><code>서브쿼리(subquery)</code>를 통해 집계 함수 사용할 수 있다.  </p>\n<pre><code class=\"language-cmd\"># 최고 기온의 해당 도시 구하기  \nSELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather);\n\n# 결과\n  city\n---------------\nSan Francisco\n(1 row)\n</code></pre>\n</li>\n<li>\n<p><code>GROUP BY 절</code>과 함께 사용하여 다양하고 유용한 결과를 볼 수 있다.  </p>\n<pre><code class=\"language-cmd\"># 각 도시별 최고기온 출력\nSELECT city, max(temp_lo) FROM weather GROUP BY city;\n\n# 결과\n  city      | max\n---------------+-----\nHayward       |  37\nSan Francisco |  46\n(2 rows)\n</code></pre>\n</li>\n<li>\n<p>집계된 자료에 대해서 어떤 조건이 주어질 때는 <code>HAVING 구문</code>을 사용한다.  </p>\n<pre><code class=\"language-cmd\">SELECT city, max(temp_lo) FROM weather GROUP BY city\n  HAVING max(temp_lo) &#x3C; 40;\n\n# 결과\ncity   | max\n---------+-----\nHayward |  37\n(1 row)\n</code></pre>\n</li>\n<li>\n<p><code>LIKE 연산자</code>를 이용한 예제  </p>\n<pre><code class=\"language-cmd\"># 각 도시별 최고 기온이 40도가 되지 않는 목록들 중 도시 이름이 S로 시작하는 자료 출력\nSELECT city, max(temp_lo) FROM weather WHERE city LIKE 'S%'(1) GROUP BY city\n  HAVING max(temp_lo) &#x3C; 40;\n</code></pre>\n</li>\n<li>집계 함수를 사용할 때는 WHERE절과 HAVING절의 관계를 반드시 숙지하고 있어야 한다. WHERE절은 조회할 집계되지 않은 자료에 대한 조건이고, HAVING은 집계된 자료에 대한 조건이다. 그래서 WHERE절의 조건으로 HAVING절이 사용될 수 없고, 일반적으로 HAVING절 다음에는 집계함수가 사용된다. WHERE 다음에는 집계할 대상에 대한 조건이, HAVING 다음에는 그 자료를 집계한 값에 대한 조건을 사용한다.</li>\n</ul>\n<h3>자료 갱신</h3>\n<p>이미 입력되어 있는 자료를 수정하기 위해 <code>UPDATE 명령</code>을 사용한다.  </p>\n<pre><code class=\"language-cmd\"># 11월 28일 이후 자료에 대해 최고/최저 기온을 각각 2도씩 낮추기\nUPDATE weather\n    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2\n    WHERE date > '1994-11-28';\n</code></pre>\n<h3>자료 삭제</h3>\n<p>한 테이블에서 필요 없는 자료를 삭제하기 위해 <code>DELETE 명령</code>을 사용한다.  </p>\n<pre><code class=\"language-cmd\">DELETE FROM weather WHERE city = 'Hayward';\n</code></pre>\n<ul>\n<li>삭제 컬럼을 지정하지 않을 경우 해당 테이블의 전체 자료가 삭제될 수 있으니 주의해야 한다.</li>\n</ul>\n<h2>고급 기능</h2>\n<p>좀더 심화된 SQL 명령을 통해 관리 작업을 단순화 하고, 지료의 손실, 손상을 막을 수 있도록 한다.  </p>\n<h3>뷰(View)</h3>\n<p>기본적인 뷰를 만들고 응용프로그램에서 사용하면, 뷰가 참조하는 원래 테이블의 자료구조가 만들어진 뷰에 영향을 미치지 않는 범위에서 얼마든지 확장되고 수정될 수 있다.</p>\n<pre><code class=\"language-cmd\">CREATE VIEW myview AS\n    SELECT city, temp_lo, temp_hi, prcp, date, location\n        FROM weather, cities\n        WHERE city = name;\n\nSELECT * FROM myview;\n</code></pre>\n<h3>참조키</h3>\n<p>JOIN을 수행할 때 한 테이블에서 자료를 잘못 입력한 경우 완벽하게 찾을 수 없는 문제가 발생한다. 또한 한 테이블에서 특정 칼럼이 삭제되는 경우 다른 테이블의 정보가 쓸모 없어질 수 있다. 따라서 한 테이블의 특정 칼럼을 반드시 다른 테이블의 칼럼에서 사용해야만 입력할 수 있도록 테이블 관계를 다시 정의한다. 이것을 <code>참조 무결성(referential integrity)</code>이라 한다.  </p>\n<pre><code class=\"language-cmd\"># weather의 도시명을 입력할 때는 cities 테이블의 도시명을 사용해야 한다.\nCREATE TABLE cities (\n        city     varchar(80) primary key,\n        location point\n);\n\nCREATE TABLE weather (\n        city      varchar(80) references cities(city),\n        temp_lo   int,\n        temp_hi   int,\n        prcp      real,\n        date      date\n);\n</code></pre>\n<ul>\n<li>잘못된 자료를 입력할 경우 제약 조건을 위반했다는 오류 메시지가 나타난다.</li>\n<li>참조키 기능은 응용 프로그램에서 해야할 일들을 대폭 줄여줌과 동시에 자료의 관계성을 보다 견고하게 만들어 준다.</li>\n</ul>\n<h3>트랜잭션</h3>\n<p>트랜잭션이란 모든 데이터베이스 시스템에서 기본적인 한 개념이다. 트랜잭션의 핵심은 여러 개의 작업이 최종적으로 하나로 취급된다는 것이다. 이것을 전부 적용 혹은 전부 취소 작업이라 부른다. 각각의 트랜잭션은 독립적이어서 동시에 발생한 트랜잭션에 대해서는 그 트랜잭션 안에서의 데이터만 적용된다. 또, 하나의 트랜잭션 안에서 어떤 작업 도중 오류가 발생되었다면, 이전에 적용되었던 모든 작업들은 취소된다.  </p>\n<pre><code class=\"language-cmd\"># 은행 데이터베이스: 각 계좌의 현 잔액을 보관하는 accounts 테이블과 각 계좌의 거래내역을 보관하는 braches 테이블로 구성되어 있다.\n# Alice 계좌에서 $100.00을 빼서 Bob 계좌로 이체\nUPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';\nUPDATE branches SET balance = balance - 100.00\n    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');\nUPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Bob';\nUPDATE branches SET balance = balance + 100.00\n    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');\n</code></pre>\n<ul>\n<li>만약 위 네 개 작업 도중 부분적으로 작업을 성공하고 나머지는 실패한다면 각 계좌에 남아있는 금액이 이상해진다. 이 문제를 방지하기 위해서 하나의 작업군이 전부 처리가 되든지, 아니면 전부 취소가 되는 작업이 필요하다. </li>\n<li><code>트랜잭션</code>을 이용하여 하나의 트랜잭션 내에서의 작업이 하나로 처리되는 것을 트랜잭션의 <code>원자성(atomic)</code>이라 한다.</li>\n<li>또한, 트랜잭션 작업이 정상적으로 끝났을 경우 그 변경된 자료가 어떠한 간섭 없이 저장되어야 하고, 저장된 자료는 손상되지 않아야 한다. 이를 위해 하나의 트랜잭션에서 발생하는 모든 작업들을 영구저장장치(하드디스크 등)에 기록하며, 이를 <code>내구성(durability)</code>라 한다.</li>\n<li>트랜잭션의 중요한 또 하나의 속성은 하나의 트랜잭션은 다른 트랜잭션에 의해 간섭받지 않아야 한다는 것이다. 즉, 동시에 여러 개의 트랜잭션이 발생했을 때 각각의 트랜잭션은 다른 트랜잭션에서 변경되고 있는 자료들에 대해서는 참조하거나 간섭할 수 없어야 하며 이를 <code>고립성(isolation)</code>이라 한다. - 따라서 트랜잭션은 각각의 명령이 수행될 때마다 그 변경 사항이 데이터베이스의 원래 자료에 영향을 주는 것이 아니라 트랜잭션 영역 안에 있는 모든 작업이 끝났을 때 한꺼번에 그 변경사항이 데이터베이스에 적용된다. 이때부터 다른 트랜잭션이 그 변경된 데이터를 참조할 수 있게 되고, 이를 <code>정합성(consistency)</code>라 한다.  </li>\n<li>\n<p>트랜잭션 작업을 하기 위해서 <code>BEGIN</code>과 <code>COMMIT</code> 명령을 지정한다.  </p>\n<pre><code class=\"language-cmd\">BEGIN;\nUPDATE accounts SET balance = balance - 100.00\n  WHERE name = 'Alice';\n-- etc etc\nCOMMIT;\n</code></pre>\n</li>\n<li>작업 도중 다음 작업을 더이상 진행하지 말아야 할 경우 <code>ROLLBACK</code> 명령을 사용해서 모든 작업을 취소하고 트랜잭션을 종료한다.</li>\n<li>PostgreSQL에서는 모든 SQL 구문은 트랜잭션 안에서 실행되는 것으로 간주한다. BEGIN 명령을 명시적으로 실행하지 않더라도 실행하고자 하는 명령 앞 뒤에 BEGIN과 성공 시 COMMIT 명령을 함께 사용한다. 이 때 BEGIN과 COMMIT 사이의 영역을 <code>트랜잭션 블록</code>이라 한다. (몇몇 클라이언트 라이브러리는 자동으로 BEGIN, COMMIT 명령을 포함해서 실행되기 때문에 사용자가 트랜잭션을 지정하면 오류가 발생할 수 있으므로 라이브러리 문서를 참조해야 한다.)</li>\n<li>트랜잭션 안에서 savepoint를 지정해서 작업을 좀 더 유연하게 처리할 수 있다. savepoint란 여기까지 작업이 정상 처리 되었다면 <code>ROLLBACK TO 명령</code>을 이용해서 그 지점 전까지 작업한 것에 대해서는 작업한 내용을 보장하겠다고 표시하는 지점이다. 이 지점을 표시하기 위해 <code>SAVEPOINT 명령</code>을 이용한다. savepoint로 취소 작업을 진행 한 뒤에도 계속 트랜잭션 내 작업을 진행할 수 있으며 작업을 진행하다가도 언제든 해당 savepoint로 돌아갈 수 있다. 또한 더이상 savepoint가 필요 없다고 판단되면 삭제해서 시스템 자원을 늘릴 수도 있다. <code>주의 사항</code>은 특정 savepoint로 돌아갈 경우 그 지점 이후에 지정해두었던 다른 savepoint들도 모두 사라진다.</li>\n<li>\n<p>트랜잭션 내에서 일어나는 모든 작업은 그 트랜잭션이 커밋되기 전까지 다른 사용자가 볼 수 없다.  </p>\n<pre><code class=\"language-cmd\"># savepoint를 사용한 은행 거래 예제 \nBEGIN;\nUPDATE accounts SET balance = balance - 100.00\n  WHERE name = 'Alice';\nSAVEPOINT my_savepoint;\nUPDATE accounts SET balance = balance + 100.00\n  WHERE name = 'Bob';\n-- 에구 ... Wally한테 가야하는 거였는데...\nROLLBACK TO my_savepoint;\nUPDATE accounts SET balance = balance + 100.00\n  WHERE name = 'Wally';\nCOMMIT;\n</code></pre>\n</li>\n</ul>\n<h3>윈도우 함수</h3>\n<p>윈도우 함수는 테이블에서 row 집합을 대상으로 계산하는 함수다. row 집합은 한 row에 대해서 어떠한 방식으로 관계된 것이며, 이 함수는 row 집합 단위로 계산한다는 점에서 집계 함수와 비슷하다. 집계 함수는 해당되는 row 집합에 대해서 하나의 row로 그 결과물을 보여주지만, 윈도우 함수는 각 row 단위로 그 처리결과를 출력한다. 쿼리 결과의 현재 row 뿐 아니라 더 많은 것을 접근할수도 있다.  </p>\n<pre><code class=\"language-cmd\"># 각 부서별 평균 임금과 각 직원별 급여 비교\nSELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;\n\n# 결과\n  depname  | empno | salary |          avg          \n-----------+-------+--------+-----------------------\n develop   |    11 |   5200 | 5020.0000000000000000\n develop   |     7 |   4200 | 5020.0000000000000000\n develop   |     9 |   4500 | 5020.0000000000000000\n develop   |     8 |   6000 | 5020.0000000000000000\n develop   |    10 |   5200 | 5020.0000000000000000\n personnel |     5 |   3500 | 3700.0000000000000000\n personnel |     2 |   3900 | 3700.0000000000000000\n sales     |     3 |   4800 | 4866.6666666666666667\n sales     |     1 |   5000 | 4866.6666666666666667\n sales     |     4 |   4800 | 4866.6666666666666667\n(10 rows)\n</code></pre>\n<ul>\n<li>첫번째~세번째 칼럼은 empsalary 테이블의 실제 row이다. 네번째 칼럼은 depname 칼럼 값을 기준으로 그룹회된 자료의 평균값을 각 row마다 보여준다. <code>OVER 절</code>을 이용한 avg 집계 함수는 윈도우 함수로 처리된다.</li>\n<li>윈도우 함수 뒤에는 항상 <code>OVER 절</code>을 사용한다. 이 규칙은 함수를 윈도우 함수로 처리할 것인지 그렇지 않은지 구분하는 문법상 규칙이다. OVER 절에는 윈도우 함수의 계산 대상이 되는 row들을 집합화하는 방법을 정의한다. </li>\n<li><code>PARTITION BY</code>로 정의하는 목록은 같은 그룹인지 다른 그룹인지 구분하는 기준으로 사용되고, 같은 그룹 내에서는 현재 row 값도 포함해서 계산된 윈도우 함수의 결과값을 공유한다.</li>\n<li>\n<p>또한 OVER절로 집합화하는 row들의 정렬 순서를 <code>ORDER BY 절</code>을 사용해서 지정할 수 있다.  </p>\n<pre><code class=\"language-cmd\"># 부서명을 기준으로 급여가 많은 자료부터 차례로 출력\nSELECT depname, empno, salary,\n    rank() OVER (PARTITION BY depname ORDER BY salary DESC)\nFROM empsalary;\n\n# 결과\ndepname  | empno | salary | rank \n-----------+-------+--------+------\ndevelop   |     8 |   6000 |    1\ndevelop   |    10 |   5200 |    2\ndevelop   |    11 |   5200 |    2\ndevelop   |     9 |   4500 |    4\ndevelop   |     7 |   4200 |    5\npersonnel |     2 |   3900 |    1\npersonnel |     5 |   3500 |    2\nsales     |     1 |   5000 |    1\nsales     |     4 |   4800 |    2\nsales     |     3 |   4800 |    2\n(10 rows)\n</code></pre>\n</li>\n<li><code>rank 함수</code>를 사용하여 순위를 보여주며, rank 함수의 입력 매개변수는 필요없다. 뒤에 오는 OVER절에서 이 함수에서 처리해야할 모든 입력 정보들이 다 정의되었기 때문이다.</li>\n<li>윈도우 함수의 계산 대상이 되는 row는 FROM 다음부터 WERE, GROUP BY, HAVING 절로 각 조건에 맞게 걸러진 <code>가상 테이블</code>의 각 row이다. WEHRE 조건절을 통해 이미 걸러진 row에 대해서는 윈도우 함수의 계산 대상이 되지 않는다. </li>\n<li>하나의 쿼리에 여러개의 윈도우 함수를 사용할 수 있다. 이 함수들은 각각의 OVER절을 사용하여 각각 자료를 집합화 한다. 하지만 이 집합화 대상이 되는 가상 테이블은 같아야 한다.</li>\n<li>ODER BY, PARTITION BY 절을 생략할 수 있으며, 윈도우 함수가 처리하는 같은 집합은 처리 결과 모든 row의 집합이 된다.</li>\n<li>\n<p>또 하나 중요한 사항은 <code>윈도우 프레임(window frame)</code>이라는 개념인데, 구분 대상이 되는 row 집합들 가운데 현재 윈도우 함수가 처리하는 row 집합을 뜻한다. 많은 윈도우 함수들이 이 윈도우 프레임 단위로 계산을 한다(전부는 아니다).  </p>\n<pre><code class=\"language-cmd\"># ORDER BY 생략\nSELECT salary, sum(salary) OVER () FROM empsalary;\n\n# 결과\nsalary |  sum  \n--------+-------\n5200 | 47100\n5000 | 47100\n3500 | 47100\n4800 | 47100\n3900 | 47100\n4200 | 47100\n4500 | 47100\n4800 | 47100\n6000 | 47100\n5200 | 47100\n(10 rows)\n\n# ORDER BY 정의\nSELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;\n\n# 결과\nsalary |  sum  \n--------+-------\n3500 |  3500\n3900 |  7400\n4200 | 11600\n4500 | 16100\n4800 | 25700\n4800 | 25700\n5000 | 30700\n5200 | 41100\n5200 | 41100\n6000 | 47100\n(10 rows)\n</code></pre>\n</li>\n<li>윈도우 함수는 <code>현재 row를 포함해서</code> 급여가 제일 적은 것부터 차례대로 함수 결과를 그때 그때 출력한다.</li>\n<li>윈도우 함수는 SELECT 항목 영역 안에서와 ORDER BY 절에서만 사용할 수 있다. 그 외 GROUP BY 절이나 HAVING, WHERE 절에는 사용할 수 없다. 논리적으로 이 함수의 처리 대상이 되는 입력 매개 변수값이 이미 결정이 나야하기 때문이다. 같은 이유로 윈도우 함수의 입력 매개 변수로 집계함수의 결과를 사용할 수 있지만, 그 반대는 불가능하다.</li>\n<li>\n<p>윈도우 함수를 사용한 결과에 대한 검색 조건이나, 재집계가 필요하다면 서브쿼리를 사용할 수 있다.  </p>\n<pre><code class=\"language-cmd\"># rank 값이 3보다 작은 자료 출력\nSELECT depname, empno, salary, enroll_date\nFROM\n(SELECT depname, empno, salary, enroll_date,\n        rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos\n  FROM empsalary\n) AS ss\nWHERE pos &#x3C; 3;\n</code></pre>\n</li>\n<li>\n<p>여러 개의 윈도우 함수를 함께 쓸 때는 각각 OVER 절을 사용해야 하는데, 이 때 지정할 윈도우 프레임이 복잡하다면 오류가 날 가능성이 커진다. 이 문제를 줄이기 위해 <code>WINDOW 절</code>을 이용한다.  </p>\n<pre><code class=\"language-cmd\">SELECT sum(salary) OVER w, avg(salary) OVER w\nFROM empsalary\nWINDOW w AS (PARTITION BY depname ORDER BY salary DESC);\n</code></pre>\n</li>\n</ul>\n<h3>상속</h3>\n<p>상속은 개게지향 데이터베이스에서 사용하는 개념이다. 상속은 데이터베이스 설계 방법에 대한 새로운 가능성을 제시한다.  </p>\n<pre><code class=\"language-cmd\"># 전통적인 개념으로 자료구조를 설계\nCREATE TABLE capitals (\n  name       text,\n  population real,\n  altitude   int,    -- (in ft)\n  state      char(2)\n);\n\nCREATE TABLE non_capitals (\n  name       text,\n  population real,\n  altitude   int     -- (in ft)\n);\n\nCREATE VIEW cities AS\n  SELECT name, population, altitude FROM capitals\n    UNION\n  SELECT name, population, altitude FROM non_capitals;\n\n\n# inherits을 통해 테이블 상속\nCREATE TABLE cities (\n  name       text,\n  population real,\n  altitude   int     -- (in ft)\n);\n\nCREATE TABLE capitals (\n  state      char(2)\n) INHERITS (cities);\n</code></pre>\n<ul>\n<li>\n<p>하나의 테이블은 자신이 상위 테이블이 되거나 여러개의 상위 테이블을 상속받을 수 있다. 또한 그 테이블의 자료 조회는 하위 테이블의 모든 자료를 포함해서 조회한다.  </p>\n<pre><code class=\"language-cmd\"># 고도가 500 ft.보다 높은 수도와 도시 출력\nSELECT name, altitude\nFROM cities\nWHERE altitude > 500;\n\n# 고도가 500 ft.보다 높은 도시만 출력\nSELECT name, altitude\n  FROM ONLY cities\n  WHERE altitude > 500;\n</code></pre>\n</li>\n<li><code>ONLY 예약어</code>를 통해 조건을 추가할 수 있으며, SELECT, UPDATE, DELETE에서도 그대로 적용된다.</li>\n<li>테이블 상속 기능은 유용하지만 유니크 제약조건, 참조키 같은 부분에서 그리 깔끔한 해결책을 제시하고 있지는 않다.</li>\n</ul>\n<h2>Reference</h2>\n<ul>\n<li>SQL 언어: <a href=\"https://postgresql.kr/docs/9.4/tutorial.html\">https://postgresql.kr/docs/9.4/tutorial.html</a></li>\n</ul>","id":"b8c8c26f-09bc-5759-8a7e-c81ffbc8f2c0"},"allPosts":{"edges":[{"node":{"id":"7f695fca-e5ce-5c55-970b-e8855f99b61a"},"next":{"fields":{"slug":"/posts/java-script-1-개요/"},"frontmatter":{"title":"JavaScript (1) - 개요"}},"previous":null},{"node":{"id":"9f46ad6e-455d-53e9-8d4c-4794e5af39dd"},"next":{"fields":{"slug":"/posts/java-script-2-문법과-자료형/"},"frontmatter":{"title":"JavaScript (2) - 문법과 자료형"}},"previous":{"fields":{"slug":"/posts/hadoop/"},"frontmatter":{"title":"Hadoop"}}},{"node":{"id":"27ea8f29-94a3-5302-a637-efd0af842208"},"next":{"fields":{"slug":"/posts/java-script-3-제어흐름과-에러처리-loop-함수-표현식과-연산자-숫자와-날짜-텍스트-서식-정규-표현식/"},"frontmatter":{"title":"JavaScript (3) - 제어흐름과 에러처리, Loop, 함수, 표현식과 연산자, 숫자와 날짜, 텍스트 서식, 정규 표현식"}},"previous":{"fields":{"slug":"/posts/java-script-1-개요/"},"frontmatter":{"title":"JavaScript (1) - 개요"}}},{"node":{"id":"7470f1ce-f71d-5772-a8be-806ed3f7cc66"},"next":{"fields":{"slug":"/posts/java-script-4-loop와-반복-함수-표현식과-연산자-숫자와-날자-텍스트-서식-정규표현식/"},"frontmatter":{"title":"JavaScript (4) - Loop와 반복, 함수, 표현식과 연산자, 숫자와 날자, 텍스트 서식, 정규표현식"}},"previous":{"fields":{"slug":"/posts/java-script-2-문법과-자료형/"},"frontmatter":{"title":"JavaScript (2) - 문법과 자료형"}}},{"node":{"id":"c54308e0-d7a2-5d1c-b8ae-ecbfd04ed1ac"},"next":{"fields":{"slug":"/posts/java-script-5-collections/"},"frontmatter":{"title":"JavaScript (5) - Collections"}},"previous":{"fields":{"slug":"/posts/java-script-3-제어흐름과-에러처리-loop-함수-표현식과-연산자-숫자와-날짜-텍스트-서식-정규-표현식/"},"frontmatter":{"title":"JavaScript (3) - 제어흐름과 에러처리, Loop, 함수, 표현식과 연산자, 숫자와 날짜, 텍스트 서식, 정규 표현식"}}},{"node":{"id":"c8b65dec-7fef-5ef0-a515-27ae182dff3e"},"next":{"fields":{"slug":"/posts/java-script-6-objects/"},"frontmatter":{"title":"JavaScript (6) - Objects"}},"previous":{"fields":{"slug":"/posts/java-script-4-loop와-반복-함수-표현식과-연산자-숫자와-날자-텍스트-서식-정규표현식/"},"frontmatter":{"title":"JavaScript (4) - Loop와 반복, 함수, 표현식과 연산자, 숫자와 날자, 텍스트 서식, 정규표현식"}}},{"node":{"id":"6814abc2-41a1-520c-bd24-a8d2d02424fb"},"next":{"fields":{"slug":"/posts/java-script-7-반복기-및-생성기-메타-프로그래밍/"},"frontmatter":{"title":"JavaScript (7) - 반복기 및 생성기, 메타 프로그래밍"}},"previous":{"fields":{"slug":"/posts/java-script-5-collections/"},"frontmatter":{"title":"JavaScript (5) - Collections"}}},{"node":{"id":"2fa87adf-6f94-54db-a8e4-7ab4990ba5e6"},"next":{"fields":{"slug":"/posts/restful-api/"},"frontmatter":{"title":"Restful API"}},"previous":{"fields":{"slug":"/posts/java-script-6-objects/"},"frontmatter":{"title":"JavaScript (6) - Objects"}}},{"node":{"id":"54319bda-39af-5fa4-9eee-7f84ee580c1a"},"next":{"fields":{"slug":"/posts/ci-cd/"},"frontmatter":{"title":"CI/CD"}},"previous":{"fields":{"slug":"/posts/java-script-7-반복기-및-생성기-메타-프로그래밍/"},"frontmatter":{"title":"JavaScript (7) - 반복기 및 생성기, 메타 프로그래밍"}}},{"node":{"id":"2311c1d2-b785-582e-a9a9-d80750b5d505"},"next":{"fields":{"slug":"/posts/annotation/"},"frontmatter":{"title":"Annotation"}},"previous":{"fields":{"slug":"/posts/restful-api/"},"frontmatter":{"title":"Restful API"}}},{"node":{"id":"2e8c37a8-a44a-5356-b617-dc7b22034c2a"},"next":{"fields":{"slug":"/posts/di와-자동-di/"},"frontmatter":{"title":"DI와 자동 DI"}},"previous":{"fields":{"slug":"/posts/ci-cd/"},"frontmatter":{"title":"CI/CD"}}},{"node":{"id":"443ae298-350d-531c-a42c-34e0acb0cdd8"},"next":{"fields":{"slug":"/posts/spring-mvc-pattern/"},"frontmatter":{"title":"Spring MVC Pattern"}},"previous":{"fields":{"slug":"/posts/annotation/"},"frontmatter":{"title":"Annotation"}}},{"node":{"id":"64980158-2ad8-5c44-91a8-a0185a6d4f6b"},"next":{"fields":{"slug":"/posts/orm과-jpa-2/"},"frontmatter":{"title":"ORM과 JPA (2)"}},"previous":{"fields":{"slug":"/posts/di와-자동-di/"},"frontmatter":{"title":"DI와 자동 DI"}}},{"node":{"id":"5128821c-b701-5848-9979-bb91ec9c5836"},"next":{"fields":{"slug":"/posts/orm과-jpa-1/"},"frontmatter":{"title":"ORM과 JPA (1)"}},"previous":{"fields":{"slug":"/posts/spring-mvc-pattern/"},"frontmatter":{"title":"Spring MVC Pattern"}}},{"node":{"id":"d4549afd-0095-5810-b492-b843ca6e2f88"},"next":{"fields":{"slug":"/posts/apache-spark-1-개요/"},"frontmatter":{"title":"Apache Spark (1) - 개요"}},"previous":{"fields":{"slug":"/posts/orm과-jpa-2/"},"frontmatter":{"title":"ORM과 JPA (2)"}}},{"node":{"id":"46426481-29ee-5d00-aa6c-cf05d52490f6"},"next":{"fields":{"slug":"/posts/동시성-처리/"},"frontmatter":{"title":"동시성 처리"}},"previous":{"fields":{"slug":"/posts/orm과-jpa-1/"},"frontmatter":{"title":"ORM과 JPA (1)"}}},{"node":{"id":"6eed9dfa-e294-5b19-a225-cd43d6cb982a"},"next":{"fields":{"slug":"/posts/apache-spark-2-rdd/"},"frontmatter":{"title":"Apache Spark (2) - RDD"}},"previous":{"fields":{"slug":"/posts/apache-spark-1-개요/"},"frontmatter":{"title":"Apache Spark (1) - 개요"}}},{"node":{"id":"e46642ac-6d65-51b8-a535-21a9e3eabb56"},"next":{"fields":{"slug":"/posts/database/"},"frontmatter":{"title":"DATABASE"}},"previous":{"fields":{"slug":"/posts/동시성-처리/"},"frontmatter":{"title":"동시성 처리"}}},{"node":{"id":"f77c8cbf-3a58-53fc-bd32-592702676a11"},"next":{"fields":{"slug":"/posts/erd/"},"frontmatter":{"title":"ERD"}},"previous":{"fields":{"slug":"/posts/apache-spark-2-rdd/"},"frontmatter":{"title":"Apache Spark (2) - RDD"}}},{"node":{"id":"f016fc75-8476-5493-8ac1-e2862773f3e7"},"next":{"fields":{"slug":"/posts/git-사용법/"},"frontmatter":{"title":"Git 사용법"}},"previous":{"fields":{"slug":"/posts/database/"},"frontmatter":{"title":"DATABASE"}}},{"node":{"id":"9f5a9a91-7af6-5ca3-b20f-d6e177e46c68"},"next":{"fields":{"slug":"/posts/jpa-1-query/"},"frontmatter":{"title":"JPA (1) - Query"}},"previous":{"fields":{"slug":"/posts/erd/"},"frontmatter":{"title":"ERD"}}},{"node":{"id":"b4e07799-70a4-523d-90ec-741e18230194"},"next":{"fields":{"slug":"/posts/j-query/"},"frontmatter":{"title":"jQuery"}},"previous":{"fields":{"slug":"/posts/git-사용법/"},"frontmatter":{"title":"Git 사용법"}}},{"node":{"id":"ef05bf06-2d53-5323-820b-98f46a906289"},"next":{"fields":{"slug":"/posts/jpa-2-specification/"},"frontmatter":{"title":"JPA (2) - Specification"}},"previous":{"fields":{"slug":"/posts/jpa-1-query/"},"frontmatter":{"title":"JPA (1) - Query"}}},{"node":{"id":"571df319-d1dd-59b6-a588-7a5db12c6b3d"},"next":{"fields":{"slug":"/posts/kubernetes/"},"frontmatter":{"title":"Kubernetes"}},"previous":{"fields":{"slug":"/posts/j-query/"},"frontmatter":{"title":"jQuery"}}},{"node":{"id":"a78eb59a-78b3-5c86-bcc2-f09ea58fab23"},"next":{"fields":{"slug":"/posts/node-js/"},"frontmatter":{"title":"NodeJS"}},"previous":{"fields":{"slug":"/posts/jpa-2-specification/"},"frontmatter":{"title":"JPA (2) - Specification"}}},{"node":{"id":"3c37f3d1-7097-5528-a31b-12bcdcd937ab"},"next":{"fields":{"slug":"/posts/oop/"},"frontmatter":{"title":"OOP"}},"previous":{"fields":{"slug":"/posts/kubernetes/"},"frontmatter":{"title":"Kubernetes"}}},{"node":{"id":"fe690dd1-ec0c-544b-a44f-131d80987565"},"next":{"fields":{"slug":"/posts/postgre-sql-1-개요/"},"frontmatter":{"title":"PostgreSQL (1) - 개요"}},"previous":{"fields":{"slug":"/posts/node-js/"},"frontmatter":{"title":"NodeJS"}}},{"node":{"id":"6268f141-e6af-5f89-a55b-2174ef57651f"},"next":{"fields":{"slug":"/posts/postgre-sql-2-psql/"},"frontmatter":{"title":"PostgreSQL (2) - PSQL"}},"previous":{"fields":{"slug":"/posts/oop/"},"frontmatter":{"title":"OOP"}}},{"node":{"id":"b8c8c26f-09bc-5759-8a7e-c81ffbc8f2c0"},"next":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}},"previous":{"fields":{"slug":"/posts/postgre-sql-1-개요/"},"frontmatter":{"title":"PostgreSQL (1) - 개요"}}},{"node":{"id":"1a663d51-139e-500f-a209-04faaebd2e85"},"next":{"fields":{"slug":"/posts/react-hook/"},"frontmatter":{"title":"React Hook"}},"previous":{"fields":{"slug":"/posts/postgre-sql-2-psql/"},"frontmatter":{"title":"PostgreSQL (2) - PSQL"}}},{"node":{"id":"b227a2c1-7853-5450-a1be-f3e1c83307b4"},"next":{"fields":{"slug":"/posts/redux-react-redux/"},"frontmatter":{"title":"Redux & React-Redux"}},"previous":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}}},{"node":{"id":"80979747-a7b7-5e5d-81bb-30729e2e16bd"},"next":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}},"previous":{"fields":{"slug":"/posts/react-hook/"},"frontmatter":{"title":"React Hook"}}},{"node":{"id":"a82c048c-1eea-54e3-912d-ae875640e04e"},"next":{"fields":{"slug":"/posts/swagger/"},"frontmatter":{"title":"Swagger"}},"previous":{"fields":{"slug":"/posts/redux-react-redux/"},"frontmatter":{"title":"Redux & React-Redux"}}},{"node":{"id":"18c2a54b-1a71-511c-824c-f437be00f3ef"},"next":{"fields":{"slug":"/posts/web-rtc/"},"frontmatter":{"title":"WebRTC"}},"previous":{"fields":{"slug":"/posts/react/"},"frontmatter":{"title":"React"}}},{"node":{"id":"d54a4c19-013d-538a-893d-ff8f62d34d7a"},"next":{"fields":{"slug":"/posts/tomcat-사용법/"},"frontmatter":{"title":"Tomcat 사용법"}},"previous":{"fields":{"slug":"/posts/swagger/"},"frontmatter":{"title":"Swagger"}}},{"node":{"id":"d2056881-058f-5f23-88ec-cf613dff77f0"},"next":null,"previous":{"fields":{"slug":"/posts/web-rtc/"},"frontmatter":{"title":"WebRTC"}}}]}},"pageContext":{"id":"b8c8c26f-09bc-5759-8a7e-c81ffbc8f2c0"}},"staticQueryHashes":["2001315320"]}